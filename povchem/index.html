<!DOCTYPE html>

<!--
2019/02/18 It's well past when I should have started a changelog for this.
This time I changed povchem.inc to work with a new font and added instructions
for how to use that font to this page.

2019/02/18 (2) Clarified some error messages and improved the input sequence
interface.

2019/02/22 Brought bond removal behavior on nuclear reactions in line with
in-game observations.  Also fixed a couple instances in this file where
"times.ttf" was invoked regardless of the current font setting
-->

<html>
<head>

<meta charset = "UTF-8">

<title>PovChem</title>

<style>
table {text-align:center}
</style>

<script>

var console_text = "";
var log_num = 0;

var atom_abbrevs = ["[invalid]", "H", "He",
  "Li", "Be", "B", "C", "N", "O", "F", "Ne",
  "Na", "Mg", "Al", "Si", "P", "S", "Cl", "Ar",
  "K", "Ca", "Sc", "Ti", "V", "Cr", "Mn", "Fe", "Co", "Ni", "Cu", "Zn", "Ga",
    "Ge", "As", "Se", "Br", "Kr",
  "Rb", "Sr", "Y", "Zr", "Nb", "Mo", "Tc", "Ru", "Rh", "Pd", "Ag", "Cd", "In",
    "Sn", "Sb", "Te", "I", "Xe",
  "Cs", "Ba", "La", "Ce", "Pr", "Nd", "Pm", "Sm", "Eu", "Gd", "Tb", "Dy", "Ho",
    "Er", "Tm", "Yb", "Lu", "Hf", "Ta", "W", "Re", "Os", "Ir", "Pt", "Au", "Hg",
    "Tl", "Pb", "Bi", "Po", "At", "Rn",
  "Fr", "Ra", "Ac", "Th", "Pa", "U", "Np", "Pu", "Am", "Cm", "Bk", "Cf", "Es",
    "Fm", "Md", "No", "Lr", "Rf", "Db", "Sg", "Bh", "Hs", "Mt",

  "(Delta)", "(Theta)", "(Sigma)", "(Omega)"
  ];

var atom_names = ["[invalid]", "Hydrogen", "Helium",
  "Lithium", "Beryllium", "Boron", "Carbon", "Nitrogen", "Oxygen", "Fluorine",
    "Neon",
  "Sodium", "Magnesium", "Aluminum", "Silicon", "Phosphorus", "Sulfur",
    "Chlorine", "Argon",
  "Potassium", "Calcium", "Scandium", "Titanium", "Vanadium", "Chromium",
    "Manganese", "Iron", "Cobalt", "Nickel", "Copper", "Zinc", "Gallium",
    "Germanium", "Arsenic", "Selenium", "Bromine", "Krypton",
  "Rubidium", "Strontium", "Yttrium", "Zirconium", "Niobium", "Molybdenum",
    "Technetium", "Ruthenium", "Rhodium", "Palladium", "Silver", "Cadmium",
    "Indium", "Tin", "Antimony", "Tellurium", "Iodine", "Xenon",
  "Cesium", "Barium", "Lanthanum", "Cerium", "Praseodymium", "Neodymium",
    "Promethium", "Samarium", "Europium", "Gadolinium", "Terbium", "Dysprosium",
    "Holmium", "Erbium", "Thulium", "Ytterbium", "Lutetium", "Hafnium",
    "Tantalum", "Tungsten", "Rhenium", "Osmium", "Iridium", "Platinum", "Gold",
    "Mercury", "Thallium", "Lead", "Bismuth", "Polonium", "Astatine", "Radon",
  "Francium", "Radium", "Actinium", "Thorium", "Protactinium", "Uranium",
    "Neptunium", "Plutonium", "Americium", "Curium", "Berkelium", "Californium",
    "Einsteinium", "Fermium", "Mendelevium", "Nobelium", "Lawrencium",
    "Rutherfordium", "Dubnium", "Seaborgium", "Bohrium", "Hassium",
    "Meitnerium",

  "Element Delta", "Element Theta", "Element Sigma", "Element Omega"
  ];

var max_bonds = [-1,
  1,                                                                                           0,
  1, 2,                                                                         3, 4, 5, 2, 1, 0,
  1, 2,                                                                         4, 4, 5, 6, 7, 0,
  1, 2,                                           3, 4, 5, 6, 7, 6, 5, 4, 4, 2, 3, 4, 5, 6, 7, 0,
  1, 2,                                           3, 4, 5, 6, 7, 8, 6, 4, 3, 2, 3, 4, 5, 6, 7, 0,
  1, 2, 3, 4, 4, 3, 3, 3, 3, 3, 4, 3, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 6, 6, 5, 4, 3, 4, 5, 6, 7, 0,
  1, 2, 3, 4, 5, 6, 7, 7, 6, 4, 4, 4, 3, 3, 3, 3, 3, 4, 5, 6, 7, 8, 6,

  12, 12, 12, 12
  ];


var origin_to_position_translates = ["OOPS someone asked for position 0",
  "<-4.5, 3.5, 0>", "<-3.5, 3.5, 0>", "<-2.5, 3.5, 0>", "<-1.5, 3.5, 0>",
    "<-0.5, 3.5, 0>", "<0.5, 3.5, 0>", "<1.5, 3.5, 0>", "<2.5, 3.5, 0>",
    "<3.5, 3.5, 0>", "<4.5, 3.5, 0>",
  "<-4.5, 2.5, 0>", "<-3.5, 2.5, 0>", "<-2.5, 2.5, 0>", "<-1.5, 2.5, 0>",
    "<-0.5, 2.5, 0>", "<0.5, 2.5, 0>", "<1.5, 2.5, 0>", "<2.5, 2.5, 0>",
    "<3.5, 2.5, 0>", "<4.5, 2.5, 0>",
  "<-4.5, 1.5, 0>", "<-3.5, 1.5, 0>", "<-2.5, 1.5, 0>", "<-1.5, 1.5, 0>",
    "<-0.5, 1.5, 0>", "<0.5, 1.5, 0>", "<1.5, 1.5, 0>", "<2.5, 1.5, 0>",
    "<3.5, 1.5, 0>", "<4.5, 1.5, 0>",
  "<-4.5, 0.5, 0>", "<-3.5, 0.5, 0>", "<-2.5, 0.5, 0>", "<-1.5, 0.5, 0>",
    "<-0.5, 0.5, 0>", "<0.5, 0.5, 0>", "<1.5, 0.5, 0>", "<2.5, 0.5, 0>",
    "<3.5, 0.5, 0>", "<4.5, 0.5, 0>",
  "<-4.5, -0.5, 0>", "<-3.5, -0.5, 0>", "<-2.5, -0.5, 0>", "<-1.5, -0.5, 0>",
    "<-0.5, -0.5, 0>", "<0.5, -0.5, 0>", "<1.5, -0.5, 0>", "<2.5, -0.5, 0>",
    "<3.5, -0.5, 0>", "<4.5, -0.5, 0>",
  "<-4.5, -1.5, 0>", "<-3.5, -1.5, 0>", "<-2.5, -1.5, 0>", "<-1.5, -1.5, 0>",
    "<-0.5, -1.5, 0>", "<0.5, -1.5, 0>", "<1.5, -1.5, 0>", "<2.5, -1.5, 0>",
    "<3.5, -1.5, 0>", "<4.5, -1.5, 0>",
  "<-4.5, -2.5, 0>", "<-3.5, -2.5, 0>", "<-2.5, -2.5, 0>", "<-1.5, -2.5, 0>",
    "<-0.5, -2.5, 0>", "<0.5, -2.5, 0>", "<1.5, -2.5, 0>", "<2.5, -2.5, 0>",
    "<3.5, -2.5, 0>", "<4.5, -2.5, 0>",
  "<-4.5, -3.5, 0>", "<-3.5, -3.5, 0>", "<-2.5, -3.5, 0>", "<-1.5, -3.5, 0>",
    "<-0.5, -3.5, 0>", "<0.5, -3.5, 0>", "<1.5, -3.5, 0>", "<2.5, -3.5, 0>",
    "<3.5, -3.5, 0>", "<4.5, -3.5, 0>",
  ];

var label_grid_to_real_grid = [0,
  24, 25, 26, 27,
  34, 35, 36, 37,
  44, 45, 46, 47,
  54, 55, 56, 57
  ];

var big_label_grid_to_real_grid = [0,
  4,  5,  6,  7,
  14, 15, 16, 17,
  24, 25, 26, 27,
  34, 35, 36, 37,
  44, 45, 46, 47,
  54, 55, 56, 57,
  64, 65, 66, 67,
  74, 75, 76, 77
  ];

var UP_STR = "Up";
var DOWN_STR = "Down";
var LEFT_STR = "Left";
var RIGHT_STR = "Right";
var BONDER_STR = "Bonder";
var SENSOR_STR = "Atom Sensor";
var FUSE_TARGET_STR = "Fusion Target";
var FISS_TARGET_STR = "Fission Target";
var TUNNEL_STR = "Quantum Tunnel";
var START_STR = "Start";
var WALDO_DIR_STR = "Waldo Direction";
var BOND_PLUS_STR = "Bond +";
var BOND_MINUS_STR = "Bond -";
var GRABDROP_STR = "Grab/Drop";
var GRAB_STR = "Grab";
var DROP_STR = "Drop";
var IN_ALPHA_STR = "In Alpha";
var IN_BETA_STR = "In Beta";
var OUT_PSI_STR = "Out Psi";
var OUT_OMEGA_STR = "Out Omega";
var SYNC_STR = "Sync";
var ROT_CLOCK_STR = "Rotate Clockwise";
var ROT_CCLOCK_STR = "Rotate Counterclockwise";
var SENS_REDIR_STR = "Sensor Redirect";
var FUSE_STR = "Fuse";
var SPLIT_STR = "Split";
var FLIP_FLOP_STR = "Flip Flop";
var SWAP_STR = "Swap (activate quantum tunnel)";
var RED_STR = "Red";
var BLUE_STR = "Blue";
var REACTOR_STR = "Reactor";

var directions = [UP_STR, DOWN_STR, LEFT_STR, RIGHT_STR];
var controls = [START_STR, WALDO_DIR_STR, BOND_PLUS_STR, BOND_MINUS_STR,
  GRABDROP_STR, GRAB_STR, DROP_STR, IN_ALPHA_STR, IN_BETA_STR, OUT_PSI_STR,
  OUT_OMEGA_STR, SYNC_STR, ROT_CLOCK_STR, ROT_CCLOCK_STR, SENS_REDIR_STR,
  FUSE_STR, SPLIT_STR, FLIP_FLOP_STR, SWAP_STR
  ];
var colors = [RED_STR, BLUE_STR];

// reactor device locations
var bonder_spots = [];
var sensor_spot = 0;
var fuse_left = 0;
var fuse_right = 0;
var fiss_left = 0;
var fiss_right = 0;
var tunnel_one = 0;
var tunnel_other = 0;
var reactor_things_array = [];
var molecule_a1 = [];
var molecule_a2 = [];
var molecule_a3 = [];
var molecule_b1 = [];
var molecule_b2 = [];
var molecule_b3 = [];
var molecule_psi_label = [];
var molecule_omega_label = [];
var alpha_sequence_array = [];
var beta_sequence_array = [];

var reactor_atoms = [];
var label_atoms = [];


// atom whatcha_doins
var WD_UNKNOWN = "wd_unknown";  // unassigned or haven't figured out yet
var WD_NOTHING = "wd_nothing";  // known that it is not moving
var WD_MOVELEFT = "wd_moveleft";
var WD_MOVERIGHT = "wd_moveright";
var WD_MOVEUP = "wd_moveup";
var WD_MOVEDOWN = "wd_movedown";
var WD_ROTCLOCK = "wd_rotclock";
var WD_ROTCOUNTERCLOCK = "wd_rotatecounterclock";
var WD_ROTCLOCKPRELIM = "wd_rotclockprelim";  // turns out I need these...
var WD_ROTCOUNTERCLOCKPRELIM = "wd_rotcounterclockprelim";

// departure statuses
var DS_UNKNOWN = "ds_unknown";  // unassigned or haven't figured out yet
var DS_NONE = "ds_none";  // not leaving
var DS_DEPARTCHECK = "ds_departcheck";  // an output has been called and this
  // atom is within the output region... if this status can propagate to all
  // atoms in the molecule it will be removed from the reactor
var DS_DEPARTCONFIRM = "ds_departconfirm";  // all atoms in that molecule are
  // within the output region
var DS_DEPARTFAIL = "ds_departfail";  // at least one atom in that molecule is
  // outside the output region
var DS_DEPARTBLOCK = "ds_departblock";  // atoms of this molecule cannot leave
  // on this cycle because another molecule has already been chosen for
  // departure

// some strings for verify_molecule(), below, to return
var VERIFY_OK = "ok";  // the one we hope to get
var VERIFY_NOTHING = "no atoms present";  // nothing to do... just about as good
var VERIFY_BAD_BOND = "all bonds must have atoms on both ends";
var VERIFY_NOT_BIG_PSI = "the gray regions may only be used for a label for large output \u03c8";
var VERIFY_NOT_CONNECTED = "there cannot be more than one molecule in there -- connect the separate pieces";
var VERIFY_WHOOPS = "bond mismatch -- this one may be my fault";
// var VERIFY_WARN_EXCESS_BONDS = "Warning: an atom has more bonds than it can usually make";
var VERIFY_WARN_EXCESS_BONDS = "An atom has more bonds than it can usually make";
var VERIFY_COLLISION = "two or more atoms occupy the same spot -- this one's got to be my fault, sorry";
var VERIFY_ERROR = "The function encountered an error";

// this thing, now that I want to make warnings and errors more prominent
var warning_error_timer_ref;

// a few functions to make sure some strings are good

function validate_name(what)
{
  if(typeof(what) != typeof("")) return false;
  if(what == BONDER_STR) return true;
  if(what == SENSOR_STR) return true;
  if(what == FUSE_TARGET_STR) return true;
  if(what == FISS_TARGET_STR) return true;
  if(what == TUNNEL_STR) return true;
  return (controls.indexOf(what) != -1);
}

function validate_color(what)
{
  if(typeof(what) != typeof("")) return false;
  return (colors.indexOf(what) != -1);
}

function validate_direction(what)
{
  if(typeof(what) != typeof("")) return false;
  return (directions.indexOf(what) != -1);
}

function validate_grid(where)  // valid grid number
{
  if(isNaN(where)) return false;
  if(where < 1) return false;
  if(where > 80) return false;
  if(where != Math.round(where)) return false;
  return true;
}

// red/blue things object constructor
function reactor_thing(where, what_thing, what_color, which_way, which_atom)
{
  this.location = where;
  this.object_type = what_thing;
  this.color = what_color;
  this.direction = which_way;
  this.atom = which_atom;
  this.state = 0;
  this.prev_state = 0;
}


// atom object constructor
function atom()  // no parameters -- just set what's needed later
{
  this.atomic_number = 0;
  this.bond_left = 0;
  this.bond_right = 0;
  this.bond_up = 0;
  this.bond_down = 0;
  this.position = 0;

  this.most_recent_cycle = 0;
  this.whatcha_doin = WD_UNKNOWN;
  this.axis_position = 0;  // necessary for rotations
  this.departure_status = DS_NONE;
  this.next_position = 0;

  this.new_copy = function()
  {
    // make a new copy of itself and return that copy
    var copy_atom = new atom();
    copy_atom.atomic_number = this.atomic_number;
    copy_atom.bond_left = this.bond_left;
    copy_atom.bond_right = this.bond_right;
    copy_atom.bond_up = this.bond_up;
    copy_atom.bond_down = this.bond_down;
    copy_atom.position = this.position;
    copy_atom.most_recent_cycle = this.most_recent_cycle;
    copy_atom.whatcha_doin = this.whatcha_doin;
    copy_atom.axis_position = this.axis_position;
    copy_atom.departure_status = this.departure_status;
    copy_atom.next_position = this.next_position;
    return copy_atom;
  };
}


// finds the index, in respective arrays, of atoms in given positions in the
// reactor grid or the molecule drawing tool.
// where: the position to look for an atom
// use_label: bool -- false == reactor grid; true == atom drawing tool
// return value: on success, returns a valid index; on error or if there is
//   no atom at that position, returns -1
function find_atom_index(where, use_label)
{
  var array_ref;
  var loop;

  if(!validate_grid(where)) return -1;
  if(typeof(use_label) != typeof(false)) return -1;

  if(use_label)
  {
    if(where > 32) return -1;
    array_ref = label_atoms;
  }
  else
  {
    array_ref = reactor_atoms;
  }

  for(loop = 0; loop < array_ref.length; ++loop)
  {
    if(array_ref[loop].position === where) return loop;
  }

  return -1;
}


// useful for dragging the rest of the molecule along with an atom -- called
// recursively
// where: position in either grid to start or continue the flood fill
// status: one of the WD_* or DS_* strings above (the function will figure out
//   where that status should be put)
// use_label: bool -- false == reactor grid; true == atom drawing tool
// returns a bool -- false if there was an error, true if not
//
// there's a better one below, strictly for the reactor grid during the
// reaction simulation
function flood_fill(where, status, use_label)
{
  if(!validate_grid(where)) return false;
  if(typeof(status) != typeof("")) return false;
  if(typeof(use_label) != typeof(false)) return false;

  if(use_label && (where > 32)) return false;

  var wd_or_ds;  // true: WD; false: DS
  var atom_index;
  var other_position;

  if((status == WD_UNKNOWN) || (status == WD_NOTHING) ||
    (status == WD_MOVELEFT) || (status == WD_MOVERIGHT) ||
    (status == WD_MOVEUP) || (status == WD_MOVEDOWN) ||
    (status == WD_ROTCLOCK) || (status == WD_ROTCOUNTERCLOCK))
  {
    wd_or_ds = true;
  }
  else if((status == DS_NONE) || (status == DS_DEPARTCHECK) ||
    (status == DS_DEPARTCONFIRM) || (status == DS_DEPARTFAIL) ||
    (status == DS_DEPARTBLOCK) || (status == DS_UNKNOWN))
  {
    wd_or_ds = false;
  }
  else
  {
    return false;
  }

  // has the fill already reached this one?
  atom_index = find_atom_index(where, use_label);
  if(atom_index < 0) return false;

  if(wd_or_ds)
  {
    if(use_label)
    {
      if(label_atoms[atom_index].whatcha_doin == status) return true;
    }
    else
    {
      if(reactor_atoms[atom_index].whatcha_doin == status) return true;
    }
  }
  else
  {
    if(use_label)
    {
      if(label_atoms[atom_index].departure_status == status) return true;
    }
    else
    {
      if(reactor_atoms[atom_index].departure_status == status) return true;
    }
  }

  // nope, so fill this one and then see what neighbors need to be filled
  if(wd_or_ds)
  {
    if(use_label)
    {
      label_atoms[atom_index].whatcha_doin = status;
    }
    else
    {
      reactor_atoms[atom_index].whatcha_doin = status;
    }
  }
  else
  {
    if(use_label)
    {
      label_atoms[atom_index].departure_status = status;
    }
    else
    {
      reactor_atoms[atom_index].departure_status = status;
    }
  }

  if(use_label)
  {
    if(label_atoms[atom_index].bond_up > 0)
    {
      if(where <= 4) return false;
      other_position = (where - 4);
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(label_atoms[atom_index].bond_down > 0)
    {
      if(where >= 29) return false;
      other_position = (where + 4);
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(label_atoms[atom_index].bond_left > 0)
    {
      if((where % 4) == 1) return false;
      other_position = (where - 1);
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(label_atoms[atom_index].bond_right > 0)
    {
      if((where % 4) == 0) return false;
      other_position = (where + 1);
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
  }
  else
  {
    if(reactor_atoms[atom_index].bond_up > 0)
    {
      other_position = move_up(where);
      if(other_position == 0) return false;
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(reactor_atoms[atom_index].bond_down > 0)
    {
      other_position = move_down(where);
      if(other_position == 0) return false;
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(reactor_atoms[atom_index].bond_left > 0)
    {
      other_position = move_left(where);
      if(other_position == 0) return false;
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
    if(reactor_atoms[atom_index].bond_right > 0)
    {
      other_position = move_right(where);
      if(other_position == 0) return false;
      if(flood_fill(other_position, status, use_label) == false) return false;
    }
  }

  return true;
}


// turns out I need more stuff for the actual reaction simulation, so here's
// another flood-fill/status-propagate function that does that more stuff
// spot: the location on the grid to which this propagate is being applied...
//   and the function will recursively apply it to any bonded neighbors
// new_cycle: the cycle on which the status is being propagated
// status: one of the WD_* or DS_* strings above (the function will figure out
//   where that status should be put)
// rot_axis: if the molecule is rotating, the atoms will need to know the grid
//   location around which it is rotating... this tells them.
// returns false on an error, true otherwise
function propagate(spot, new_cycle, status, rot_axis)
{
  var use_departs;
  var axis_too;

  var atom_idx;
  var other_position;

  if(!validate_grid(spot)) return false;
  if(typeof(new_cycle) != typeof(1)) return false;
  if(typeof(status) != typeof("")) return false;

  if((status === WD_UNKNOWN) || (status === WD_NOTHING) ||
    (status === WD_MOVELEFT) || (status === WD_MOVERIGHT) ||
    (status === WD_MOVEUP) || (status === WD_MOVEDOWN) ||
    (status === WD_ROTCLOCKPRELIM) || (status === WD_ROTCOUNTERCLOCKPRELIM) ||
    (status === WD_ROTCLOCK) || (status === WD_ROTCOUNTERCLOCK))
  {
    use_departs = false;
    if((status === WD_ROTCLOCK) || (status === WD_ROTCOUNTERCLOCK) ||
      (status === WD_ROTCLOCKPRELIM) || (status === WD_ROTCOUNTERCLOCKPRELIM))
    {
      if(!validate_grid(rot_axis)) return false;
      axis_too = true;
    }
    else
    {
      axis_too = false;
    }
  }
  else if((status === DS_NONE) || (status === DS_DEPARTCHECK) ||
    (status === DS_DEPARTCONFIRM) || (status === DS_DEPARTFAIL) ||
    (status === DS_DEPARTBLOCK) || (status === DS_UNKNOWN))
  {
    use_departs = true;
    axis_too = false;
  }
  else
  {
    return false;
  }

  // find the atom being referred to
  atom_idx = find_atom_index(spot, false);
  if(atom_idx < 0) return false;

  // if that status has already propagated here, nothing further to do

  // but if it's a new cycle, we definitely need to stay, so only do further
  // end-case checks if it's the same cycle
  if(reactor_atoms[atom_idx].most_recent_cycle === new_cycle)
  {
    // and then I guess the only end case is if the old status matches the new
    if(use_departs)
    {
      if(reactor_atoms[atom_idx].departure_status === status) return true;
    }
    else
    {
      if(reactor_atoms[atom_idx].whatcha_doin === status)
      {
        // just gotta make sure axis is the same, too, if necessary
        if(axis_too)
        {
          if(reactor_atoms[atom_idx].axis_position === rot_axis) return true;
        }
        else
        {
          return true;
        }
      }
    }
  }

  // all right, then -- propagate!
  reactor_atoms[atom_idx].most_recent_cycle = new_cycle;
  if(use_departs)
  {
    reactor_atoms[atom_idx].departure_status = status;
  }
  else
  {
    reactor_atoms[atom_idx].whatcha_doin = status;
    if(axis_too)
    {
      reactor_atoms[atom_idx].axis_position = rot_axis;
    }
  }

  // and not just to itself, but to its neighbors, too -- it's called
  // "propagate" after all...
  if(reactor_atoms[atom_idx].bond_left > 0)
  {
    other_position = move_left(spot);
    if(other_position === 0) return false;
    propagate(other_position, new_cycle, status, rot_axis);
  }
  if(reactor_atoms[atom_idx].bond_right > 0)
  {
    other_position = move_right(spot);
    if(other_position === 0) return false;
    propagate(other_position, new_cycle, status, rot_axis);
  }
  if(reactor_atoms[atom_idx].bond_up > 0)
  {
    other_position = move_up(spot);
    if(other_position === 0) return false;
    propagate(other_position, new_cycle, status, rot_axis);
  }
  if(reactor_atoms[atom_idx].bond_down > 0)
  {
    other_position = move_down(spot);
    if(other_position === 0) return false;
    propagate(other_position, new_cycle, status, rot_axis);
  }

  return true;
}


// verify that the molecule in the drawing tool is valid
// returns one of the VERIFY_* strings above
// allow_gray: bool -- if true, molecule is allowed to use gray areas
function verify_molecule(allow_gray)
{
  var ref;
  var loop;
  var ref_list;
  var new_atom;
  var something_useful;

  label_atoms.length = 0;

  // assemble label_atoms array from the drawing tool
  for(loop = 1; loop <= 32; ++loop)
  {
    ref = document.getElementById("l" + loop + "_atom_select");
    if(ref == null)
    {
      // console_write("Error: bad id");
      error_write("bad id");
      label_atoms.length = 0;
      return VERIFY_ERROR;
    }
    if(ref.selectedIndex == 0) continue;  // save a level of nesting

    if((loop > 16) && (!allow_gray))
    {
      label_atoms.length = 0;
      return VERIFY_NOT_BIG_PSI;
    }

    new_atom = new atom();
    new_atom.atomic_number = ref.selectedIndex;
    new_atom.position = loop;

    if(loop > 4)
    {
      ref_list = document.getElementsByClassName("l" + (loop - 4) + "l" + loop + "bond");
      if(ref_list.length != 3)
      {
        // console_write("Error: something wrong there");
        error_write("something wrong there");
        label_atoms.length = 0;
        return VERIFY_ERROR;
      }
      something_useful = 0;
      if(ref_list[0].checked) ++something_useful;
      if(ref_list[1].checked) ++something_useful;
      if(ref_list[2].checked) ++something_useful;
      new_atom.bond_up = something_useful;
    }
    if(loop < 29)
    {
      ref_list = document.getElementsByClassName("l" + loop + "l" + (loop + 4) + "bond");
      if(ref_list.length != 3)
      {
        // console_write("Error: something wrong there");
        error_write("something wrong there");
        label_atoms.length = 0;
        return VERIFY_ERROR;
      }
      something_useful = 0;
      if(ref_list[0].checked) ++something_useful;
      if(ref_list[1].checked) ++something_useful;
      if(ref_list[2].checked) ++something_useful;
      if((loop >= 13) && (loop <= 16) && (something_useful > 0) && (!allow_gray))
      {
        label_atoms.length = 0;
        return VERIFY_NOT_BIG_PSI;
      }
      new_atom.bond_down = something_useful;
    }
    if((loop % 4) != 1)
    {
      ref_list = document.getElementsByClassName("l" + (loop - 1) + "l" + loop + "bond");
      if(ref_list.length != 3)
      {
        // console_write("Error: something wrong there");
        error_write("something wrong there");
        label_atoms.length = 0;
        return VERIFY_ERROR;
      }
      something_useful = 0;
      if(ref_list[0].checked) ++something_useful;
      if(ref_list[1].checked) ++something_useful;
      if(ref_list[2].checked) ++something_useful;
      new_atom.bond_left = something_useful;
    }
    if((loop % 4) != 0)
    {
      ref_list = document.getElementsByClassName("l" + loop + "l" + (loop + 1) + "bond");
      if(ref_list.length != 3)
      {
        // console_write("Error: something wrong there");
        error_write("something wrong there");
        label_atoms.length = 0;
        return VERIFY_ERROR;
      }
      something_useful = 0;
      if(ref_list[0].checked) ++something_useful;
      if(ref_list[1].checked) ++something_useful;
      if(ref_list[2].checked) ++something_useful;
      new_atom.bond_right = something_useful;
    }

    label_atoms.push(new_atom);
  }

  // first of all, were there any atoms in there?
  if(label_atoms.length == 0)
  {
    return VERIFY_NOTHING;
  }

  // check the label_atoms array -- start by flooding to change status
  // from WD_UNKNOWN to WD_NOTHING
  // nope, can't flood fill until we've verified there are no bonds to nowhere
  /***
  if(!flood_fill(label_atoms[0].position, WD_NOTHING, true))
  {
    console_write("Error during flood fill");
    return VERIFY_ERROR;
  }
  ***/

  // now loop through and check various things
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    // start with a basic check
    if((label_atoms[loop].atomic_number < 1) ||
      (label_atoms[loop].atomic_number > 113) ||
      (label_atoms[loop].atomic_number != Math.round(label_atoms[loop].atomic_number)))
    {
      // console_write("Error: bad atomic number " + label_atoms[loop].atomic_number);
      error_write("bad atomic number " + label_atoms[loop].atomic_number);
      label_atoms.length = 0;
      return VERIFY_ERROR;
    }

    // verify it's a single connected molecule
    // not yet -- can't check result of a flood until we can do the flood
    /***
    if(label_atoms[loop].whatcha_doin != WD_NOTHING)
    {
      label_atoms.length = 0;
      return VERIFY_NOT_CONNECTED;
    }
    ***/

    // verify there are no bonds to nowhere
    if(label_atoms[loop].bond_up > 0)
    {
      something_useful = find_atom_index((label_atoms[loop].position - 4), true);
      if(something_useful == -1)
      {
        label_atoms.length = 0;
        return VERIFY_BAD_BOND;
      }
    }
    if(label_atoms[loop].bond_down > 0)
    {
      something_useful = find_atom_index((label_atoms[loop].position + 4), true);
      if(something_useful == -1)
      {
        label_atoms.length = 0;
        return VERIFY_BAD_BOND;
      }
    }
    if(label_atoms[loop].bond_left > 0)
    {
      something_useful = find_atom_index((label_atoms[loop].position - 1), true);
      if(something_useful == -1)
      {
        label_atoms.length = 0;
        return VERIFY_BAD_BOND;
      }
    }
    if(label_atoms[loop].bond_right > 0)
    {
      something_useful = find_atom_index((label_atoms[loop].position + 1), true);
      if(something_useful == -1)
      {
        label_atoms.length = 0;
        return VERIFY_BAD_BOND;
      }
    }

    something_useful = (label_atoms[loop].bond_up + label_atoms[loop].bond_down +
      label_atoms[loop].bond_left + label_atoms[loop].bond_right);
    if(something_useful > max_bonds[label_atoms[loop].atomic_number])
    {
      // console_write(VERIFY_WARN_EXCESS_BONDS + " (" + something_useful +
      warning_write(VERIFY_WARN_EXCESS_BONDS + " (" + something_useful +
        " bonds vs. max. " + max_bonds[label_atoms[loop].atomic_number] +
        " on " + atom_names[label_atoms[loop].atomic_number] +
        " at position " + label_atoms[loop].position + ")");
    }
  }

  // now we can flood
  if(!flood_fill(label_atoms[0].position, WD_NOTHING, true))
  {
    // console_write("Error during flood fill");
    error_write("Error during flood fill");
    return VERIFY_ERROR;
  }

  // loop again to check
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    if(label_atoms[loop].whatcha_doin != WD_NOTHING)
    {
      label_atoms.length = 0;
      return VERIFY_NOT_CONNECTED;
    }
  }

  // leave label_atoms array as-is so that whatever called this can use it

  return VERIFY_OK;
}



function console_write(what)
{
  var ref;
  var temp_string;

  if(typeof(what) != typeof("")) return;
  ref = document.getElementById("console_output");
  if(ref == null)
  {
    alert("Console output reference error.");
    return;
  }

  ++log_num;
  temp_string = "";
  temp_string += log_num;
  temp_string += ". ";
  temp_string += new Date();
  temp_string += "\n";
  temp_string += what;
  temp_string += "\n\n";

  console_text = temp_string + console_text;

  ref.value = console_text;
}


function move_left(from_where)
{
  if(typeof(from_where) != typeof(1))
  {
    // console_write("Error in move_left(): type mismatch");
    error_write("Error in move_left(): type mismatch");
    return 0;
  }

  if((from_where < 1) || (from_where > 80))
  {
    return 0;
  }

  if((from_where == 1) || (from_where == 11) || (from_where == 21) ||
    (from_where == 31) || (from_where == 41) || (from_where == 51) ||
    (from_where == 61) || (from_where == 71))
  {
    return 0;
  }

  return (from_where - 1);
}

function move_right(from_where)
{
  if(typeof(from_where) != typeof(1))
  {
    // console_write("Error in move_right(): type mismatch");
    error_write("Error in move_right(): type mismatch");
    return 0;
  }

  if((from_where < 1) || (from_where > 80))
  {
    return 0;
  }

  if((from_where == 10) || (from_where == 20) || (from_where == 30) ||
    (from_where == 40) || (from_where == 50) || (from_where == 60) ||
    (from_where == 70) || (from_where == 80))
  {
    return 0;
  }

  return (from_where + 1);
}

function move_up(from_where)
{
  if(typeof(from_where) != typeof(1))
  {
    // console_write("Error in move_up(): type mismatch");
    error_write("Error in move_up(): type mismatch");
    return 0;
  }

  if((from_where <= 10) || (from_where > 80))
  {
    return 0;
  }

  return (from_where - 10);
}

function move_down(from_where)
{
  if(typeof(from_where) != typeof(1))
  {
    // console_write("Error in move_down(): type mismatch");
    error_write("Error in move_down(): type mismatch");
    return 0;
  }

  if((from_where < 1) || (from_where >= 71))
  {
    return 0;
  }

  return (from_where + 10);
}

function move_far(from_where, how_far, direction)
{
  var sub_direction;

  if((typeof(from_where) != typeof(1)) || (typeof(how_far) != typeof(1)) ||
    (typeof(direction) != typeof("")))
  {
    // console_write("Error in move_far(): type mismatch");
    error_write("Error in move_far(): type mismatch");
    return 0;
  }

  if(!validate_direction(direction))
  {
    // console_write("Error in move_far(): bad direction");
    error_write("Error in move_far(): bad direction");
    return 0;
  }

  if(Math.round(how_far) != how_far)
  {
    // console_write("Error in move_far(): fractions not allowed");
    error_write("Error in move_far(): fractions not allowed");
    return 0;
  }

  if(how_far === 0) return from_where;

  if(how_far < 0)
  {
    if(direction === LEFT_STR) sub_direction = RIGHT_STR;
    else if(direction === RIGHT_STR) sub_direction = LEFT_STR;
    else if(direction === UP_STR) sub_direction = DOWN_STR;
    else sub_direction = UP_STR;
    return move_far(from_where, ((-1) * how_far), sub_direction);
  }

  if(how_far > 9)
  {
    return 0;
  }

  var spot = from_where;
  var loop;
  for(loop = 0; loop < how_far; ++loop)
  {
    if(direction == LEFT_STR)
    {
      spot = move_left(spot);
    }
    else if(direction == RIGHT_STR)
    {
      spot = move_right(spot);
    }
    else if(direction == UP_STR)
    {
      spot = move_up(spot);
    }
    else if(direction == DOWN_STR)
    {
      spot = move_down(spot);
    }
    else
    {
      // console_write("Error in move_far(): invalid direction");
      error_write("Error in move_far(): invalid direction");
      return 0;
    }
  }
  return spot;
}


// functions for future trigonometry
// this_spot, other_spot: strings from origin_to_position_translates
// returns: a number representing (other_spot's x or y) - (this_spot's x or y)
//   (returns null on error)
function extract_x(this_spot, other_spot)
{
  var this_x;
  var other_x;
  var work_str;

  var angle_spot;
  var comma_spot;

  if(typeof(this_spot) != typeof("")) return null;
  if(typeof(other_spot) != typeof("")) return null;

  angle_spot = this_spot.indexOf("<");
  if(angle_spot != 0) return null;
  comma_spot = this_spot.indexOf(",");
  if(comma_spot <= 0) return null;

  work_str = this_spot.substring(angle_spot + 1, comma_spot);
  this_x = Number(work_str);
  if(isNaN(this_x)) return null;

  angle_spot = other_spot.indexOf("<");
  if(angle_spot != 0) return null;
  comma_spot = other_spot.indexOf(",");
  if(comma_spot <= 0) return null;

  work_str = other_spot.substring(angle_spot + 1, comma_spot);
  other_x = Number(work_str);
  if(isNaN(other_x)) return null;

  return (other_x - this_x);
}

function extract_y(this_spot, other_spot)
{
  var this_y;
  var other_y;
  var work_str;

  var space_spot;
  var comma_spot;

  if(typeof(this_spot) != typeof("")) return null;
  if(typeof(other_spot) != typeof("")) return null;

  space_spot = this_spot.indexOf(" ");
  if(space_spot <= 0) return null;
  comma_spot = this_spot.indexOf(",", space_spot);
  if(comma_spot <= space_spot) return null;

  work_str = this_spot.substring(space_spot + 1, comma_spot);
  this_y = Number(work_str);
  if(isNaN(this_y)) return null;

  space_spot = other_spot.indexOf(" ");
  if(space_spot <= 0) return null;
  comma_spot = other_spot.indexOf(",", space_spot);
  if(comma_spot <= space_spot) return null;

  work_str = other_spot.substring(space_spot + 1, comma_spot);
  other_y = Number(work_str);
  if(isNaN(other_y)) return null;

  return (other_y - this_y);
}


// a function that will likely be useful in a few places
// stuff can be RED_STR, BLUE_STR, or REACTOR_STR
// place is a grid position
// dir_bool only applies for RED_STR or BLUE_STR and true indicates we want
//   directional controls rather than waldo instructions (but supply it
//   regardless -- it'll complain if it doesn't get it)
// return value is a string indicating what sort of device was found there
//   (if there's nothing of that type there, the returned string is empty)
function what_stuff_is_at_place(stuff, place, dir_bool)
{
  var return_val = "";

  if(typeof(stuff) != typeof(return_val))
  {
    // console_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    error_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    return return_val;
  }

  if(typeof(place) != typeof(1))
  {
    // console_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    error_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    return return_val;
  }

  if(typeof(dir_bool) != typeof(false))
  {
    // console_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    error_write("Error in what_stuff_is_at_place(): parameter is wrong type");
    return return_val;
  }

  var loop;
  var inner_loop;

  if((stuff == RED_STR) || (stuff == BLUE_STR))
  {
    for(loop = 0; loop < reactor_things_array.length; ++loop)
    {
      if(dir_bool)
      {
        // looking for any direction arrows on that spot
        if((reactor_things_array[loop].location == place) &&
          (reactor_things_array[loop].object_type == WALDO_DIR_STR) &&
          (reactor_things_array[loop].color == stuff))
        {
          return_val = reactor_things_array[loop].direction;
          return return_val;
        }
      }
      else
      {
        // looking for red/blue waldo instructions on that spot
        if((reactor_things_array[loop].location == place) &&
          (reactor_things_array[loop].object_type != WALDO_DIR_STR) &&
          (reactor_things_array[loop].color == stuff))
        {
          return_val = reactor_things_array[loop].object_type;
          return return_val;
        }
      }
    }
  }
  else if(stuff == REACTOR_STR)
  {
    // looking for reactor devices on that spot
    for(loop = 0; loop < bonder_spots.length; ++loop)
    {
      if(bonder_spots[loop] == place)
      {
        return_val = BONDER_STR;
        return return_val;
      }
    }

    if(sensor_spot == place)
    {
      return_val = SENSOR_STR;
      return return_val;
    }

    if(fuse_left == place)
    {
      return_val = FUSE_TARGET_STR;
      return return_val;
    }

    if(fuse_right == place)
    {
      return_val = FUSE_TARGET_STR;
      return return_val;
    }

    if(fiss_left == place)
    {
      return_val = FISS_TARGET_STR;
      return return_val;
    }

    if(fiss_right == place)
    {
      return_val = FISS_TARGET_STR;
      return return_val;
    }

    if(tunnel_one == place)
    {
      return_val = TUNNEL_STR;
      return return_val;
    }

    if(tunnel_other == place)
    {
      return_val = TUNNEL_STR;
      return return_val;
    }
  }
  else
  {
    // console_write("Error in what_stuff_is_at_place(): unexpected value");
    error_write("Error in what_stuff_is_at_place(): unexpected value");
    return return_val;
  }

  return return_val;
}


// In order to add some stuff, I may need to remove previous stuff.  I imagine
// this will also come in handy when I click the "Remove" button.
// where: number, grid location
// which_color: string, use one of the globals
// dir_bool: true -- directional arrow; false: other controls
// Remember that this function does not remove reactor devices, only red and
// blue controls.
// returns a bool: true -- removed that thing; false -- did not
function remove_a_control(where, which_color, dir_bool)
{
  var loop;
  var ref;
  var id_string;

  if(!validate_grid(where))
  {
    // console_write("Error: bad spot");
    error_write("bad spot");
    return false;
  }

  if(!validate_color(which_color))
  {
    // console_write("Error: bad color");
    error_write("bad color");
    return false;
  }

  if(typeof(dir_bool) != typeof(false))
  {
    // console_write("Error: that's not a bool");
    error_write("that's not a bool");
    return false;
  }

  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].location == where) &&
      (reactor_things_array[loop].color == which_color))
    {
      if(dir_bool)
      {
        if(reactor_things_array[loop].object_type == WALDO_DIR_STR)
        {
          // it's the right thing -- remove it
          id_string = "g" + where;
          if(which_color == RED_STR) id_string += "red_";
          else id_string += "blue_";
          if(reactor_things_array[loop].direction == UP_STR) id_string += "u";
          else if(reactor_things_array[loop].direction == DOWN_STR) id_string += "d";
          else if(reactor_things_array[loop].direction == LEFT_STR) id_string += "l";
          else if(reactor_things_array[loop].direction == RIGHT_STR) id_string += "r";
          else
          {
            // console_write("Error: bad direction");
            error_write("bad direction");
            return false;
          }
          ref = document.getElementById(id_string);
          if(ref == null)
          {
            // console_write("Error: bad id");
            error_write("bad id");
            return false;
          }
          ref.innerHTML = "";
          reactor_things_array.splice(loop, 1);
          return true;
        }
      }
      else
      {
        if(reactor_things_array[loop].object_type === WALDO_DIR_STR)
        {
          // what we're removing is not a direction control -- if we found
          // a direction control that matched everything else before we found
          // what we're looking for... better skip it
          continue;
        }

        if(controls.indexOf(reactor_things_array[loop].object_type) === -1)
        {
          // if current reactor thing is not a waldo instruction control
          // (even though position and color match) then it may just be a
          // reactor device that got assigned a color because that parameter
          // needed a value -- just continue
          // wait... I don't keep reactor devices in reactor_things_array...
          // oh well
          continue;
        }

        // now then, position, control type, and color all match -- there's
        // something here, so remove it
        id_string = "g" + where;
        if(which_color == BLUE_STR) id_string += "blue_";  // change it up a bit
        else id_string += "red_";
        id_string += "con";
        ref = document.getElementById(id_string);
        if(ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return false;
        }
        ref.innerHTML = "";
        reactor_things_array.splice(loop, 1);
        return true;
      }
    }
  }

  // Fell all the way out here?  Nothing there, then.
  return false;
}

function grid_button_handler(which_button)
{
  var position_ref;
  var type_ref;
  var color_ref;
  var direction_ref;
  var atom_ref;

  position_ref = document.getElementById("input_grid_number");
  type_ref = document.getElementById("grid_object_select");
  color_ref = document.getElementById("color_select");
  direction_ref = document.getElementById("direction_select");
  atom_ref = document.getElementById("input_atom_select");

  if((position_ref == null) || (type_ref == null) || (color_ref == null) ||
    (direction_ref == null) || (atom_ref == null))
  {
    // console_write("Error: reference error in add_grid_button_handler()");
    error_write("reference error in add_grid_button_handler()");
    return;
  }

  var where;
  where = Number(position_ref.value);
  if(isNaN(where))
  {
    // console_write("Error: invalid grid position");
    error_write("invalid grid position");
    return;
  }

  if((where < 1) || (where > 80) || (Math.round(where) != where))
  {
    // console_write("Error: invalid grid position");
    error_write("invalid grid position");
    return;
  }

  var what;
  what = type_ref.value;
  if(!validate_name(what))
  {
    // console_write("Error: invalid object " + String(what));
    error_write("invalid object " + String(what));
    return;
  }

  var what_color;
  what_color = color_ref.value;
  if(!validate_color(what_color))
  {
    // console_write("Error: invalid color " + String(what_color));
    error_write("invalid color " + String(what_color));
    return;
  }

  var which_way;
  which_way = direction_ref.value;
  if(!validate_direction(which_way))
  {
    // console_write("Error: invalid direction " + String(which_way));
    error_write("invalid direction " + String(which_way));
    return;
  }

  var which_atom;
  which_atom = atom_ref.selectedIndex + 1;
  if((which_atom < 1) || (which_atom > 113) ||
    (which_atom != Math.round(which_atom)))
  {
    // console_write("Error: invalid atom selection");
    error_write("invalid atom selection");
    return;
  }

  var loop;
  var id_string;
  var grid_ref;
  var new_thing;
  var so_what_was_there;
  var other_ref;  // a ref for miscellaneous use

  other_ref = document.getElementById("clear_confirm_div");
  if(other_ref == null)
  {
    error_write("Aw c'mon I just wrote that.");
    return;
  }

  if(which_button.id == "clear_grid_prelim_button")
  {
    other_ref.removeAttribute("hidden");
    return;
  }
  else
  {
    other_ref.setAttribute("hidden", "");
    if(which_button.id == "clear_grid_no") return;
  }

  if(which_button.id == "clear_grid_button")
  {
    for(loop = 1; loop <= 80; ++loop)
    {
      id_string = "g" + loop + "red_u";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "blue_u";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "red_l";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "red_con";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "reac";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "red_r";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "blue_l";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "blue_con";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "blue_r";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "red_d";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      id_string = "g" + loop + "blue_d";
      grid_ref = document.getElementById(id_string);
      if(grid_ref == null)
      {
        // console_write("Error: id not found");
        error_write("id not found");
        return;
      }
      grid_ref.innerHTML = "";

      bonder_spots.length = 0;
      sensor_spot = 0;
      fuse_left = 0;
      fuse_right = 0;
      fiss_left = 0;
      fiss_right = 0;
      tunnel_one = 0;
      tunnel_other = 0;
      reactor_things_array.length = 0;
    }

    // now add the two starts back

    grid_ref = document.getElementById("g15red_con");
    if(grid_ref == null)
    {
      // console_write("Error: id not found");
      error_write("id not found");
      return;
    }
    grid_ref.innerHTML = "Start(L)";
    new_thing = new reactor_thing(15, START_STR, RED_STR, LEFT_STR, 1);
    reactor_things_array.push(new_thing);

    grid_ref = document.getElementById("g65blue_con");
    if(grid_ref == null)
    {
      // console_write("Error: id not found");
      error_write("id not found");
      return;
    }
    grid_ref.innerHTML = "Start(L)";
    new_thing = new reactor_thing(65, START_STR, BLUE_STR, LEFT_STR, 1);
    reactor_things_array.push(new_thing);

    console_write("Grid reset.");
  }
  else if(which_button.id == "input_add")
  {
    // different things to do, depending on what it is
    if((what == BONDER_STR) || (what == SENSOR_STR) ||
      (what == FUSE_TARGET_STR) || (what == FISS_TARGET_STR) ||
      (what == TUNNEL_STR))
    {
      // first let's make sure the targets fit, if they need to
      if((what == FUSE_TARGET_STR) || (what == FISS_TARGET_STR))
      {
        if(move_right(where) == 0)
        {
          // console_write("Error: cannot place target in rightmost column.");
          error_write("cannot place target in rightmost column.");
          return;
        }

        // heck, let's just complain if there's a device in the way, too
        so_what_was_there = what_stuff_is_at_place(REACTOR_STR,
          move_right(where), false);
        if(so_what_was_there.length != 0)
        {
          // console_write("Error: there's something blocking the right half of the target at " + move_right(where) + ".  Remove it first.");
          error_write("there's something blocking the right half of the target at " + move_right(where) + ".  Remove it first.");
          return;
        }
      }

      so_what_was_there = what_stuff_is_at_place(REACTOR_STR, where, false);

      // if there's already a device there, it needs to be removed
      // if(so_what_was_there == BONDER_STR)
      // {
      // }
      // aw heck that, I already found that it's much easier simply to complain
      if(so_what_was_there.length != 0)
      {
        // console_write("Error: there's a device at position " + where + " already.  Remove it first.");
        error_write("there's a device at position " + where + " already.  Remove it first.");
        return;
      }

      // adding a reactor device is as simple as changing a number or two... or
      // maybe adding one on to the end of an array

      if(what == BONDER_STR)
      {
        if(bonder_spots.length > 8)
        {
          // console_write("Error: way too many bonders already -- might want to look into that.");
          error_write("way too many bonders already -- might want to look into that.");
          return;
        }

        if(bonder_spots.length == 8)
        {
          // console_write("Error: there are already the maximum 8 bonders on the grid.  Remove one first.");
          error_write("there are already the maximum 8 bonders on the grid.  Remove one first.");
          return;
        }

        id_string = "g" + where + "reac";
        grid_ref = document.getElementById(id_string);
        if(grid_ref == null)
        {
          // console_write("Error: bad reference");
          error_write("bad reference");
          return;
        }

        grid_ref.innerHTML = "bond";
        bonder_spots.push(where);
        console_write("Placed a bonder at position " + where + ".");
      }
      else if(what == SENSOR_STR)
      {
        // remove the old one, if necessary -- already made sure it's not here
        if(sensor_spot != 0)
        {
          if((sensor_spot < 1) || (sensor_spot > 80) ||
            (sensor_spot != Math.round(sensor_spot)))
          {
            // console_write("Error: sensor_spot got wonked somehow.");
            error_write("sensor_spot got wonked somehow.");
            return;
          }

          id_string = "g" + sensor_spot + "reac";
          grid_ref = document.getElementById(id_string);
          if(grid_ref == null)
          {
            // console_write("Error: reference problem");
            error_write("reference problem");
            return;
          }

          grid_ref.innerHTML = "";
        }

        id_string = "g" + where + "reac";
        grid_ref = document.getElementById(id_string);
        if(grid_ref == null)
        {
          // console_write("Error: reference problem");
          error_write("reference problem");
          return;
        }

        grid_ref.innerHTML = "sensor";

        // borrow id_string...
        id_string = "Placed atom sensor at position " + where;
        if(sensor_spot != 0)
        {
          id_string += " (removed old sensor at " + sensor_spot + ")";
        }
        id_string += ".";
        console_write(id_string);

        // now that we've reported it, better do it
        sensor_spot = where;
      }
      else if(what == FUSE_TARGET_STR)
      {
        if(((fuse_left == 0) && (fuse_right != 0)) ||
          ((fuse_left != 0) && (fuse_right == 0)))
        {
          // console_write("Error: wonked");
          error_write("wonked");
          return;
        }

        if(fuse_left != 0)
        {
          // remove the old target first
          if(!validate_grid(fuse_left))
          {
            // console_write("Error: bork");
            error_write("bork");
            return;
          }
          if(!validate_grid(fuse_right))
          {
            // console_write("Error: heck");
            error_write("heck");
            return;
          }

          grid_ref = document.getElementById("g" + fuse_left + "reac");
          if(grid_ref == null)
          {
            // console_write("Error: borf");
            error_write("borf");
            return;
          }
          grid_ref.innerHTML = "";

          grid_ref = document.getElementById("g" + fuse_right + "reac");
          if(grid_ref == null)
          {
            // console_write("Error: borf");
            error_write("borf");
            return;
          }
          grid_ref.innerHTML = "";
        }

        // place the fusion target
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: blark");
          error_write("blark");
          return;
        }
        grid_ref.innerHTML = "Fuse(L)";

        grid_ref = document.getElementById("g" + move_right(where) + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: blork");
          error_write("blork");
          return;
        }
        grid_ref.innerHTML = "Fuse(R)";

        id_string = "Placed fusion target at position " + where + " and ";
        id_string += move_right(where);
        if(fuse_left != 0)
        {
          id_string += " (removed old target at " + fuse_left + " and ";
          id_string += fuse_right + ")";
        }
        id_string += ".";

        fuse_left = where;
        fuse_right = move_right(where);
        console_write(id_string);
      }
      else if(what == FISS_TARGET_STR)
      {
        if(((fiss_left == 0) && (fiss_right != 0)) ||
          ((fiss_left != 0) && (fiss_right == 0)))
        {
          // console_write("Error: wumped");
          error_write("wumped");
          return;
        }

        if(fiss_left != 0)
        {
          // remove the old target first
          if(!validate_grid(fiss_left))
          {
            // console_write("Error: bronk");
            error_write("bronk");
            return;
          }
          if(!validate_grid(fiss_right))
          {
            // console_write("Error: well darn");
            error_write("well darn");
            return;
          }

          grid_ref = document.getElementById("g" + fiss_left + "reac");
          if(grid_ref == null)
          {
            // console_write("Error: brorf");
            error_write("brorf");
            return;
          }
          grid_ref.innerHTML = "";

          grid_ref = document.getElementById("g" + fiss_right + "reac");
          if(grid_ref == null)
          {
            // console_write("Error: borf");
            error_write("borf");
            return;
          }
          grid_ref.innerHTML = "";
        }

        // place the fission target
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: nuts");
          error_write("nuts");
          return;
        }
        grid_ref.innerHTML = "Fiss(L)";

        grid_ref = document.getElementById("g" + move_right(where) + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: brumpf");
          error_write("brumpf");
          return;
        }
        grid_ref.innerHTML = "Fiss(R)";

        id_string = "Placed fission target at position " + where + " and ";
        id_string += move_right(where);
        if(fiss_left != 0)
        {
          id_string += " (removed old target at " + fiss_left + " and ";
          id_string += fiss_right + ")";
        }
        id_string += ".";

        fiss_left = where;
        fiss_right = move_right(where);
        console_write(id_string);
      }
      else  // only remaining possibility is TUNNEL_STR
      {
        if((tunnel_one != 0) && (tunnel_other != 0))
        {
          // console_write("Error: two tunnels already placed.  Remove one first.");
          error_write("Two tunnels already placed.  Remove one first.");
          return;
        }

        if((tunnel_one == 0) && (tunnel_other != 0))
        {
          // should've been done elsewhere, but swap these the right way around
          tunnel_one = tunnel_other;
          tunnel_other = 0;
        }

        // at least one tunnel available to place now, and we've already made
        // sure there's nothing already there
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: well shucks");
          error_write("well shucks");
          return;
        }

        grid_ref.innerHTML = "tunl.";
        if(tunnel_one == 0)
        {
          tunnel_one = where;
        }
        else
        {
          tunnel_other = where;
        }

        id_string = "Placed a quantum tunnel at position " + where + " (";
        if(tunnel_other == 0)
        {
          id_string += "only one tunnel currently placed; solution must have 0 or 2).";
        }
        else
        {
          id_string += "both tunnels currently placed).";
        }
        console_write(id_string);
      }
    }
    else
    {
      // waldo instructions and directions
      if(what == WALDO_DIR_STR)
      {
        // okay, just directions

        // remove any old directions...
        remove_a_control(where, what_color, true);

        // add the new thing
        id_string = "g" + where;
        if(what_color == RED_STR) id_string += "red_";
        else id_string += "blue_";
        if(which_way == UP_STR) id_string += "u";
        else if(which_way == DOWN_STR) id_string += "d";
        else if(which_way == LEFT_STR) id_string += "l";
        else id_string += "r";  // validated earlier
        grid_ref = document.getElementById(id_string);
        if(grid_ref == null)
        {
          // console_write("Error: bad id... and something may have changed.");
          error_write("bad id... and something may have changed.");
          return;
        }
        if(which_way == UP_STR) grid_ref.innerHTML = "^";
        else if(which_way == DOWN_STR) grid_ref.innerHTML = "v";  // it'll do
        else if(which_way == LEFT_STR) grid_ref.innerHTML = "<";
        else grid_ref.innerHTML = ">";

        new_thing = new reactor_thing(where, what, what_color, which_way, 1);
        reactor_things_array.push(new_thing);
        id_string = "Added a " + what_color + " " + what + " (" + which_way;
        id_string += ") at position " + where + ".";
        console_write(id_string);
      }
      else
      {
        // instructions
        if(what == START_STR)
        {
          // remove the old start first
          for(loop = 0; loop < reactor_things_array.length; ++loop)
          {
            if((reactor_things_array[loop].object_type == START_STR) &&
              (reactor_things_array[loop].color == what_color))
            {
              // found the old start
              id_string = "g" + reactor_things_array[loop].location;
              if(what_color == RED_STR) id_string += "red_";
              else id_string += "blue_";
              id_string += "con";
              grid_ref = document.getElementById(id_string);
              if(grid_ref == null)
              {
                // console_write("Error: bad id");
                error_write("bad id");
                return;
              }
              grid_ref.innerHTML = "";
              reactor_things_array.splice(loop, 1);
              break;
            }
          }

          // now put the new one in
          id_string = "g" + where;
          if(what_color == RED_STR) id_string += "red_";
          else id_string += "blue_";
          id_string += "con";
          grid_ref = document.getElementById(id_string);
          if(grid_ref == null)
          {
            // console_write("Error: bad id, and it was a bad time for this to happen.");
            error_write("bad id, and it was a bad time for this to happen.");
            return;
          }
          id_string = "Start(";
          if(which_way == UP_STR) id_string += "U";
          else if(which_way == DOWN_STR) id_string += "D";
          else if(which_way == LEFT_STR) id_string += "L";
          else id_string += "R";
          id_string += ")";
          grid_ref.innerHTML = id_string;
          new_thing = new reactor_thing(where, what, what_color, which_way, 1);
          reactor_things_array.push(new_thing);
          id_string = "New " + what_color + " Start is at position " + where;
          id_string += ", heading " + which_way + ".";
          console_write(id_string);
        }
        else
        {
          // first of all, make sure we're not trying to put something in place
          // of a start instruction
          so_what_was_there = what_stuff_is_at_place(what_color, where, false);
          if(so_what_was_there == START_STR)
          {
            // console_write("Error: cannot replace a Start instruction.  Place the Start somewhere else first.");
            error_write("Cannot replace a Start instruction.  Place the Start somewhere else first.");
            return;
          }

          // Good, it's not a start and there's not a start there.  Something
          // else may need to be removed, though.
          if(so_what_was_there.length > 0)
          {
            remove_a_control(where, what_color, false);
          }

          // may as well get the grid reference here
          id_string = "g" + where;
          if(what_color == RED_STR) id_string += "red_";
          else id_string += "blue_";
          id_string += "con";
          grid_ref = document.getElementById(id_string);
          if(grid_ref == null)
          {
            // console_write("Error: bad id");
            error_write("bad id");
            return;
          }

          // add the new thing
          new_thing = new reactor_thing(where, what, what_color, which_way,
            which_atom);
          reactor_things_array.push(new_thing);

          // now the grid label
          if(what == BOND_PLUS_STR) id_string = "BOND+";
          else if(what == BOND_MINUS_STR) id_string = "BOND-";
          else if(what == GRABDROP_STR) id_string = "GR/DR";
          else if(what == GRAB_STR) id_string = "GRAB";
          else if(what == DROP_STR) id_string = "DROP";
          else if(what == IN_ALPHA_STR) id_string = "IN\u03b1";
          else if(what == IN_BETA_STR) id_string = "IN\u03b2";
          else if(what == OUT_PSI_STR) id_string = "OUT\u03c8";
          else if(what == OUT_OMEGA_STR) id_string = "OUT\u03c9";
          else if(what == SYNC_STR) id_string = "SYNC";
          else if(what == ROT_CLOCK_STR) id_string = "Rot.CLK";
          else if(what == ROT_CCLOCK_STR) id_string = "Rot.CCLK";
          else if(what == SENS_REDIR_STR)
          {
            id_string = "SensRedir<br>(";
            if(which_way == UP_STR) id_string += "u";
            else if(which_way == DOWN_STR) id_string += "d";
            else if(which_way == LEFT_STR) id_string += "l";
            else id_string += "r";
            id_string += ")" + atom_abbrevs[which_atom];
          }
          else if(what == FUSE_STR) id_string = "FUSE";
          else if(what == SPLIT_STR) id_string = "SPLIT";
          else if(what == FLIP_FLOP_STR)
          {
            id_string = "FlipFlop<br>(";
            if(which_way == UP_STR) id_string += "u";
            else if(which_way == DOWN_STR) id_string += "d";
            else if(which_way == LEFT_STR) id_string += "l";
            else id_string += "r";
            id_string += ")";
          }
          else if(what == SWAP_STR) id_string = "SWAP";
          else
          {
            // console_write("Error: really shouldn't have hit this part.");
            error_write("really shouldn't have hit this part.");
            return;
          }
          grid_ref.innerHTML = id_string;

          // and finally, the console report
          id_string = "Placed a " + what_color + " " + what;
          if((what == SENS_REDIR_STR) || (what == FLIP_FLOP_STR))
          {
            id_string += " (" + which_way + ")";
            if(what == SENS_REDIR_STR)
            {
              id_string += " (" + atom_names[which_atom] + ")";
            }
          }
          id_string += " at position " + where + ".";
          console_write(id_string);
        }
      }
    }
  }
  else if(which_button.id == "input_remove")
  {
    // removal policy: object type and color had better match; details like
    // direction and atom can be overlooked

    // find out what sort of thing is there now
    if((what == BONDER_STR) || (what == SENSOR_STR) || (what == TUNNEL_STR) ||
      (what == FUSE_TARGET_STR) || (what == FISS_TARGET_STR))
    {
      so_what_was_there = what_stuff_is_at_place(REACTOR_STR, where, false);
      if(so_what_was_there != what)
      {
        // console_write("Error: cannot remove -- no " + what + " at " + where + ".");
        error_write("cannot remove -- no " + what + " at " + where + ".");
        return;
      }

      // match -- let's do this least-to-most complex
      if(what == SENSOR_STR)
      {
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return;
        }
        grid_ref.innerHTML = "";
        sensor_spot = 0;
        console_write("Removed " + what + " from position " + where + ".");
      }
      else if(what == TUNNEL_STR)
      {
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return;
        }
        grid_ref.innerHTML = "";
        if(tunnel_one == where)
        {
          // leave tunnel_one as the deployed tunnel, if there are two out
          tunnel_one = tunnel_other;
          tunnel_other = 0;
        }
        else if(tunnel_other == where)
        {
          tunnel_other = 0;
        }
        else
        {
          // console_write("Error: now that's odd...");
          error_write("now that's odd...");
          return;
        }

        id_string = "Removed " + what + " from position " + where;
        if(tunnel_one != 0)
        {
          id_string += " (only one tunnel currently placed; solution must have 0 or 2)";
        }
        else
        {
          id_string += " (no tunnels currently placed)";
        }
        id_string += ".";
        console_write(id_string);
      }
      else if(what == FUSE_TARGET_STR)
      {
        if(!((validate_grid(fuse_left)) && (validate_grid(fuse_right))))
        {
          // console_write("Error: well dangit");
          error_write("well dangit");
          return;
        }
        grid_ref = document.getElementById("g" + fuse_left + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return;
        }
        grid_ref.innerHTML = "";
        grid_ref = document.getElementById("g" + fuse_right + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: well nuts to that");
          error_write("well nuts to that");
          return;
        }
        grid_ref.innerHTML = "";
        console_write("Removed " + what + " from position " + fuse_left + " and " + fuse_right + ".");
        fuse_left = 0;
        fuse_right = 0;
      }
      else if(what == FISS_TARGET_STR)
      {
        // same thing as above except with "fiss"!
        if(!((validate_grid(fiss_left)) && (validate_grid(fiss_right))))
        {
          // console_write("Error: well dangit");
          error_write("well dangit");
          return;
        }
        grid_ref = document.getElementById("g" + fiss_left + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return;
        }
        grid_ref.innerHTML = "";
        grid_ref = document.getElementById("g" + fiss_right + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: well nuts to that");
          error_write("well nuts to that");
          return;
        }
        grid_ref.innerHTML = "";
        console_write("Removed " + what + " from position " + fiss_left + " and " + fiss_right + ".");
        fiss_left = 0;
        fiss_right = 0;
      }
      else  // bonder
      {
        // I guess loop can hold the result of this...
        loop = bonder_spots.indexOf(where);
        if(loop < 0)
        {
          // console_write("Error: darnit, I was sure I had one of those there!");
          error_write("darnit, I was sure I had one of those there!");
          return;
        }
        bonder_spots.splice(loop, 1);
        grid_ref = document.getElementById("g" + where + "reac");
        if(grid_ref == null)
        {
          // console_write("Error: bad id");
          error_write("bad id");
          return;
        }
        grid_ref.innerHTML = "";
        console_write("Removed a " + what + " from position " + where + ".");
      }
    }
    else
    {
      // red/blue instructions or directions
      if(what == WALDO_DIR_STR)
      {
        // directions
        so_what_was_there = what_stuff_is_at_place(what_color, where, true);
        if(!validate_direction(so_what_was_there))
        {
          // console_write("Error: cannot remove -- no " + what_color + " " + what + " at " + where + ".");
          error_write("cannot remove -- no " + what_color + " " + what + " at " + where + ".");
          return;
        }

        // even if it's not the same direction, remove it anyway
        if(!remove_a_control(where, what_color, true))
        {
          // console_write("Error removing that");
          error_write("Error removing that");
          return;
        }

        // and the grid label was already handled by remove_a_control(), so
        // just log the report
        console_write("Removed a " + what_color + " " + what + " (" + so_what_was_there + ") from position " + where + ".");
      }
      else
      {
        // instructions
        so_what_was_there = what_stuff_is_at_place(what_color, where, false);
        if(so_what_was_there != what)
        {
          // console_write("Error: cannot remove -- no " + what_color + " " + what + " at " + where + ".");
          error_write("cannot remove -- no " + what_color + " " + what + " at " + where + ".");
          return;
        }
        if(so_what_was_there == START_STR)
        {
          // console_write("Error: cannot remove Start instruction.  You can place it somewhere else, though.");
          error_write("cannot remove Start instruction.  You can place it somewhere else, though.");
          return;
        }

        // build id_string (for the report) here, as it will be lost in a moment
        id_string = "Removed a " + what_color + " " + what;
        if((what == SENS_REDIR_STR) || (what == FLIP_FLOP_STR))
        {
          // gonna have to get direction (and atom) from the array
          for(loop = 0; loop < reactor_things_array.length; ++loop)
          {
            if((reactor_things_array[loop].object_type == what) &&
              (reactor_things_array[loop].location == where) &&
              (reactor_things_array[loop].color == what_color))
            {
              break;
            }
          }
          if(loop >= reactor_things_array.length)
          {
            // console_write("Error... and quite an odd one, too.");
            error_write("Error... and quite an odd one, too.");
            return;
          }

          id_string += " (" + reactor_things_array[loop].direction + ")";

          if(what == SENS_REDIR_STR)
          {
            id_string += " (" + atom_names[reactor_things_array[loop].atom] + ")";
          }
        }
        id_string += " from position " + where + ".";

        // so... validated the control and it's not a start -- out it goes
        if(!remove_a_control(where, what_color, false))
        {
          // console_write("Error removing that");
          error_write("Error removing that");
          return;
        }

        // report
        console_write(id_string);
      }
    }
  }
  else
  {
    // console_write("Error, I guess: unknown how we got to this function");
    error_write("Error, I guess: unknown how we got to this function");
    return;
  }

  // something has changed, so clear the preview and "real" textareas
  // we'll borrow grid_ref for this
  grid_ref = document.getElementById("preview_ini_output");
  if(grid_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  grid_ref.value = "";

  grid_ref = document.getElementById("preview_scene_output");
  if(grid_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  grid_ref.value = "";

  grid_ref = document.getElementById("real_ini_output");
  if(grid_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  grid_ref.value = "";

  grid_ref = document.getElementById("real_scene_output");
  if(grid_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  grid_ref.value = "";
}


function molecule_draw_clear_function()
{
  var loop;
  var id_string;
  var ref;
  var class_list;

  for(loop = 1; loop <= 32; ++loop)
  {
    // selects
    id_string = "l" + loop + "_atom_select";
    ref = document.getElementById(id_string);
    if(ref == null)
    {
      // console_write("Error: bad id");
      error_write("bad id");
      return;
    }
    ref.selectedIndex = 0;

    // checkboxes
    // %4: 1, 2, 3 connect with that +1
    // <= 28: connect with that +4
    if((loop % 4) != 0)
    {
      id_string = "l" + loop + "l" + (loop + 1) + "bond";
      class_list = document.getElementsByClassName(id_string);
      if(class_list.length != 3)
      {
        // console_write("Error: bad class or unexpected length");
        error_write("bad class or unexpected length");
        return;
      }
      class_list[0].checked = false;
      class_list[1].checked = false;
      class_list[2].checked = false;
    }
    if(loop <= 28)
    {
      id_string = "l" + loop + "l" + (loop + 4) + "bond";
      class_list = document.getElementsByClassName(id_string);
      if(class_list.length != 3)
      {
        // console_write("Error: bad class or unexpected length");
        error_write("bad class or unexpected length");
        return;
      }
      class_list[0].checked = false;
      class_list[1].checked = false;
      class_list[2].checked = false;
    }
  }
}


// reads the label, returns a string of atom symbols and counts... you know,
// like H2O -- will not have any info about bonds or positions, just counts
// (get a true from verify_molecule before calling this -- label_atoms had
// better be valid)
function get_molecule_formula()
{
  var loop;
  var moreloop;
  var return_string;
  var current_count;

  return_string = "";

  for(loop = 1; loop <= 113; ++loop)
  {
    current_count = 0;
    for(moreloop = 0; moreloop < label_atoms.length; ++moreloop)
    {
      if(label_atoms[moreloop].atomic_number === loop)
      {
        ++current_count;
      }
    }
    if(current_count > 0)
    {
      return_string += atom_abbrevs[loop];
      if(current_count > 1)
      {
        return_string += current_count;
      }
    }
  }

  // of course, this will report stuff like methane as H4C... oh well

  return return_string;
}


function set_a1_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("a1_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_a1.length = 0;
    console_write("Cleared molecule A1");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_a1.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_a1.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule A1";
  console_write(something_useful);
}

function set_a2_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("a2_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_a2.length = 0;
    console_write("Cleared molecule A2");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_a2.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_a2.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule A2";
  console_write(something_useful);
}

function set_a3_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("a3_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_a3.length = 0;
    console_write("Cleared molecule A3");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_a3.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_a3.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule A3";
  console_write(something_useful);
}

function set_b1_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("b1_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_b1.length = 0;
    console_write("Cleared molecule B1");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_b1.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_b1.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule B1";
  console_write(something_useful);
}

function set_b2_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("b2_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_b2.length = 0;
    console_write("Cleared molecule B2");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_b2.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_b2.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule B2";
  console_write(something_useful);
}

function set_b3_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("b3_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_b3.length = 0;
    console_write("Cleared molecule B3");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_b3.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_b3.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as molecule B3";
  console_write(something_useful);
}


function add_fn(what)
{
  var useful_thing;
  var ref;

  if(what.id === "add_a1") useful_thing = "A1";
  else if(what.id === "add_a2") useful_thing = "A2";
  else if(what.id === "add_a3") useful_thing = "A3";
  else if(what.id === "add_b1") useful_thing = "B1";
  else if(what.id === "add_b2") useful_thing = "B2";
  else if(what.id === "add_b3") useful_thing = "B3";
  else
  {
    // console_write("Error... dunno how we got here.");
    error_write("dunno how we got here.");
    return;
  }

  if((what.id === "add_a1") || (what.id === "add_a2") || (what.id === "add_a3"))
  {
    // alpha
    ref = document.getElementById("alpha_sequence");
    if(ref == null)
    {
      // console_write("Error: bad id");
      error_write("bad id");
      return;
    }
    alpha_sequence_array.push(useful_thing);
    // ref.value = alpha_sequence_array.toString();
    alpha_sequence_redraw();
  }
  else
  {
    // beta
    ref = document.getElementById("beta_sequence");
    if(ref == null)
    {
      // console_write("Error: bad id");
      error_write("bad id");
      return;
    }
    beta_sequence_array.push(useful_thing);
    // ref.value = beta_sequence_array.toString();
    beta_sequence_redraw();
  }
}


function clear_alpha_fn()
{
  var ref;
  var one_ref;
  var two_ref;
  var three_ref;

  ref = document.getElementById("alpha_sequence");
  one_ref = document.getElementById("a1_span");
  two_ref = document.getElementById("a2_span");
  three_ref = document.getElementById("a3_span");

  if((ref == null) || (one_ref == null) || (two_ref == null) ||
    (three_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  molecule_a1.length = 0;
  molecule_a2.length = 0;
  molecule_a3.length = 0;
  alpha_sequence_array.length = 0;
  ref.value = "";
  one_ref.innerHTML = "";
  two_ref.innerHTML = "";
  three_ref.innerHTML = "";
  console_write("Cleared \u03b1 sequence and molecules.");
}

function clear_beta_fn()
{
  var ref;
  var one_ref;
  var two_ref;
  var three_ref;

  ref = document.getElementById("beta_sequence");
  one_ref = document.getElementById("b1_span");
  two_ref = document.getElementById("b2_span");
  three_ref = document.getElementById("b3_span");
  if((ref == null) || (one_ref == null) || (two_ref == null) ||
    (three_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  molecule_b1.length = 0;
  molecule_b2.length = 0;
  molecule_b3.length = 0;
  beta_sequence_array.length = 0;
  ref.value = "";
  one_ref.innerHTML = "";
  two_ref.innerHTML = "";
  three_ref.innerHTML = "";
  console_write("Cleared \u03b2 sequence and molecules.");
}

function set_psi_label_fn()
{
  var ref;
  var use_big;
  var something_useful;
  var loop;
  var label_ref;

  ref = document.getElementById("big_psi_select");
  label_ref = document.getElementById("psi_label_span");
  if((ref == null) || (label_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  if(ref.selectedIndex === 0)
  {
    use_big = false;
  }
  else if(ref.selectedIndex === 1)
  {
    use_big = true;
  }
  else
  {
    // console_write("Error: unexpected value");
    error_write("unexpected value");
    return;
  }

  something_useful = verify_molecule(use_big);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_psi_label.length = 0;
    console_write("Cleared \u03c8 label");
    label_ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_psi_label.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_psi_label.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  label_ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as label for output \u03c8";
  console_write(something_useful);
}

function set_omega_label_fn()
{
  var something_useful;
  var loop;
  var ref;

  ref = document.getElementById("omega_label_span");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  something_useful = verify_molecule(false);
  if(something_useful === VERIFY_NOTHING)
  {
    molecule_omega_label.length = 0;
    console_write("Cleared \u03c9 label");
    ref.innerHTML = "";
    return;
  }

  if(something_useful != VERIFY_OK)
  {
    // console_write("Error: " + something_useful);
    error_write("" + something_useful);
    return;
  }

  molecule_omega_label.length = 0;
  for(loop = 0; loop < label_atoms.length; ++loop)
  {
    molecule_omega_label.push(label_atoms[loop].new_copy());
  }

  something_useful = get_molecule_formula();
  ref.innerHTML = something_useful;

  something_useful = "Set molecule " + something_useful;
  something_useful += " as label for output \u03c9";
  console_write(something_useful);
}


// figure out where all the devices, instructions, tracks, and labels should
// be and write that as POV code to a gigantic string to return
// (tiny note -- this function does not draw sensor redirectors and flip flops
// because, as they animate, they are not considered statics... the preview
// and real-thing functions that call this function will have to place those
// themselves)
// return value: a string -- empty ("") on error, gigantic bunch of POV-code
//   on success
function generate_reactor_statics()
{
  var scene_text;
  var ref;
  var loop;
  var moreloop;
  var use_big_psi;
  var useful_thing;
  var pov_color;
  var kludge;

  // arrays to keep track of tracks
  var directions_to_process = [];
  var directions_already_processed = [];
  var controls_to_process = [];
  var controls_already_processed = [];

  var which_color_this_time;
  var where_are_we_now;
  var where_were_we_just_then;
  var which_way_are_we_going;
  var checking_controls;  // bool -- true: controls; false: directions

  var use_x1;
  var use_x2;
  var use_x3;
  var how_many;
  var molecule_x1 = [];
  var molecule_x2 = [];
  var molecule_x3 = [];
  var label_1_pov;
  var label_2_pov;
  var label_3_pov;

  ref = document.getElementById("big_psi_select");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return "";
  }
  if(ref.selectedIndex === 0)
  {
    use_big_psi = false;
  }
  else if(ref.selectedIndex === 1)
  {
    use_big_psi = true;
  }
  else
  {
    // console_write("Error: unexpected value");
    error_write("unexpected value");
    return "";
  }

  /***
  ref = document.getElementById("preview_scene_output");
  if(ref == null)
  {
    console_write("Error: bad id");
    return "";
  }
  ***/

  scene_text = "#version 3.5;\n";
  scene_text += "#include \"povchem.inc\"\n\n";

  scene_text += "camera\n";
  scene_text += "{\n";
  scene_text += "  orthographic\n";
  scene_text += "  up <0, 8, 0>\n";
  scene_text += "  right <8 * (16/9), 0, 0>\n";
  scene_text += "  location <0, 0, -50>\n";
  scene_text += "  look_at 0\n";
  scene_text += "}\n\n";

  if(use_big_psi)
  {
    scene_text += "big_output_psi\n\n";
  }
  else
  {
    scene_text += "output_psi\n";
    scene_text += "output_omega\n\n";
  }

  // bonders
  for(loop = 0; loop < bonder_spots.length; ++loop)
  {
    if(!validate_grid(bonder_spots[loop]))
    {
      // console_write("Error: AW HECK");
      error_write("AW HECK");
      return "";
    }
    scene_text += "object {bonder translate ";
    scene_text += origin_to_position_translates[bonder_spots[loop]] + "}\n";

    // need a bonder join stick? check right and down
    useful_thing = move_right(bonder_spots[loop]);
    if(useful_thing != 0)
    {
      for(moreloop = 0; moreloop < bonder_spots.length; ++moreloop)
      {
        if(bonder_spots[moreloop] === useful_thing)
        {
          // need a join from right of bonder we just placed
          scene_text += "object {bonder_join translate 0.5*x translate ";
          scene_text += origin_to_position_translates[bonder_spots[loop]];
          scene_text += "}\n";
        }
      }
    }

    // that was right; now check down
    useful_thing = move_down(bonder_spots[loop]);
    if(useful_thing != 0)
    {
      for(moreloop = 0; moreloop < bonder_spots.length; ++moreloop)
      {
        if(bonder_spots[moreloop] === useful_thing)
        {
          scene_text += "object {bonder_join translate 0.5*x ";
          scene_text += "rotate -90*z translate ";
          scene_text += origin_to_position_translates[bonder_spots[loop]];
          scene_text += "}\n";
        }
      }
    }
  }

  // atom sensor
  if(sensor_spot != 0)
  {
    if(!validate_grid(sensor_spot))
    {
      // console_write("Error: temper tantrum");
      error_write("temper tantrum");
      return "";
    }

    scene_text += "object {sensor translate ";
    scene_text += origin_to_position_translates[sensor_spot] + "}\n";
  }

  // fusion target
  if(fuse_left != 0)
  {
    if(!((validate_grid(fuse_left)) && (validate_grid(fuse_right)) &&
      ((fuse_left + 1) === fuse_right)))
    {
      // console_write("Error: fusion problem -- so far energy yields from fusion reactions have been less than the energies required to start and maintain the reactions and if they can\'t get that working then humanity\'s energy future looks bleak");
      error_write("fusion problem -- so far energy yields from fusion reactions have been less than the energies required to start and maintain the reactions and if they can\'t get that working then humanity\'s energy future looks bleak");
      return "";
    }
    scene_text += "object {fusion_target translate <0.5, -0.5, 0> translate ";
    scene_text += origin_to_position_translates[fuse_left] + "}\n";
  }

  // fission target
  if(fiss_left != 0)
  {
    if(!((validate_grid(fiss_left)) && (validate_grid(fiss_right)) &&
      ((fiss_left + 1) === fiss_right)))
    {
      // console_write("Error: fission problem -- though it has been touted by some to be a \"green\" energy source, it can only be called such in the sense that it does not generate greenhouse gases.  The waste it does generate is extremely hazardous to the environment and to human life, and its storage poses a number of logistical and political problems.");
      error_write("fission problem -- though it has been touted by some to be a \"green\" energy source, it can only be called such in the sense that it does not generate greenhouse gases.  The waste it does generate is extremely hazardous to the environment and to human life, and its storage poses a number of logistical and political problems.");
      return "";
    }
    scene_text += "object {fission_target translate <0.5, -0.5, 0> translate ";
    scene_text += origin_to_position_translates[fiss_left] + "}\n";
  }

  // quantum tunnels
  if((tunnel_one != 0) || (tunnel_other != 0))
  {
    if((validate_grid(tunnel_one) && (tunnel_other === 0)) ||
      (validate_grid(tunnel_other) && (tunnel_one === 0)))
    {
      // console_write("Error: only one quantum tunnel placed; solution must have 0 or 2.");
      error_write("only one quantum tunnel placed; solution must have 0 or 2.");
      return "";
    }
    if(!((validate_grid(tunnel_one)) && (validate_grid(tunnel_other))))
    {
      // console_write("Error: quantum tunnel problem -- that's not at all what quantum tunneling means!  I am getting mad about video games!!");
      error_write("quantum tunnel problem -- that's not at all what quantum tunneling means!  I am getting mad about video games!!");
      return "";
    }
    scene_text += "object {quantum_tunnel translate ";
    scene_text += origin_to_position_translates[tunnel_one];
    scene_text += "}\nobject {quantum_tunnel translate ";
    scene_text += origin_to_position_translates[tunnel_other] + "}\n";
  }

  // now red and blue stuff
  scene_text += "\n";

  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if(controls.indexOf(reactor_things_array[loop].object_type) === -1)
    {
      // console_write("Error: thing name problem");
      error_write("thing name problem");
      return "";
    }
    if(!validate_color(reactor_things_array[loop].color))
    {
      // console_write("Error: thing color problem");
      error_write("thing color problem");
      return "";
    }
    if(!validate_grid(reactor_things_array[loop].location))
    {
      // console_write("Error: thing position problem");
      error_write("thing position problem");
    }

    // skip drawing sensor redirects and flip flops because, as they
    // animate to display changing state, they are not considered statics
    // (the main simulation will draw their state in each frame, and the
    // preview will draw static versions of them later)
    if(reactor_things_array[loop].object_type === SENS_REDIR_STR) continue;
    if(reactor_things_array[loop].object_type === FLIP_FLOP_STR) continue;

    scene_text += "object {";

    // already did a few things without it, but it's time to come back here
    // and bring this in
    if(reactor_things_array[loop].color === RED_STR) pov_color = "red";
    else pov_color = "blue";

    if(reactor_things_array[loop].object_type === START_STR)
    {
      // technical kludge: if there's also a directional indicator of the same
      // color on this square, change the start's direction to match it
      kludge = "";
      useful_thing = what_stuff_is_at_place(reactor_things_array[loop].color,
        reactor_things_array[loop].location, true);
      if(useful_thing != "")
      {
        if(!validate_direction(useful_thing))
        {
          // console_write("Error: the kludge is on the fritz");
          error_write("the kludge is on the fritz");
          return "";
        }
        if(useful_thing === UP_STR) kludge = "u";
        else if(useful_thing === DOWN_STR) kludge = "d";
        else if(useful_thing === LEFT_STR) kludge = "l";
        else kludge = "r";
      }

      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: start direction problem");
        error_write("start direction problem");
        return "";
      }
      if(reactor_things_array[loop].color === RED_STR) scene_text += "red";
      else scene_text += "blue";
      scene_text += "_start_";
      if(kludge.length > 0) scene_text += kludge;
      else if(reactor_things_array[loop].direction === DOWN_STR) scene_text += "d";
      else if(reactor_things_array[loop].direction === UP_STR) scene_text += "u";
      else if(reactor_things_array[loop].direction === LEFT_STR) scene_text += "l";
      else scene_text += "r";
    }
    else if(reactor_things_array[loop].object_type === WALDO_DIR_STR)
    {
      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: arrow direction problem");
        error_write("arrow direction problem");
        return "";
      }
      if(reactor_things_array[loop].color === RED_STR) scene_text += "red";
      else scene_text += "blue";
      scene_text += "_dir_";
      if(reactor_things_array[loop].direction === DOWN_STR) scene_text += "d";
      else if(reactor_things_array[loop].direction === UP_STR) scene_text += "u";
      else if(reactor_things_array[loop].direction === LEFT_STR) scene_text += "l";
      else scene_text += "r";
    }
    else if(reactor_things_array[loop].object_type === BOND_PLUS_STR)
    {
      if(reactor_things_array[loop].color === RED_STR) scene_text += "red";
      else scene_text += "blue";
      scene_text += "_bond_plus";
    }
    else if(reactor_things_array[loop].object_type === BOND_MINUS_STR)
    {
      scene_text += pov_color;  // there; that's much easier
      scene_text += "_bond_minus";
    }
    else if(reactor_things_array[loop].object_type === GRABDROP_STR)
    {
      scene_text += pov_color;
      scene_text += "_grabdrop";
    }
    else if(reactor_things_array[loop].object_type === GRAB_STR)
    {
      scene_text += pov_color;
      scene_text += "_grab";
    }
    else if(reactor_things_array[loop].object_type === DROP_STR)
    {
      scene_text += pov_color;
      scene_text += "_drop";
    }
    else if(reactor_things_array[loop].object_type === IN_ALPHA_STR)
    {
      scene_text += pov_color;
      scene_text += "_in_alpha";
    }
    else if(reactor_things_array[loop].object_type === IN_BETA_STR)
    {
      scene_text += pov_color;
      scene_text += "_in_beta";
    }
    else if(reactor_things_array[loop].object_type === OUT_PSI_STR)
    {
      scene_text += pov_color;
      scene_text += "_out_psi";
    }
    else if(reactor_things_array[loop].object_type === OUT_OMEGA_STR)
    {
      scene_text += pov_color;
      scene_text += "_out_omega";
    }
    else if(reactor_things_array[loop].object_type === SYNC_STR)
    {
      scene_text += pov_color;
      scene_text += "_sync";
    }
    else if(reactor_things_array[loop].object_type === ROT_CLOCK_STR)
    {
      scene_text += pov_color;
      scene_text += "_rotate_clockwise";
    }
    else if(reactor_things_array[loop].object_type === ROT_CCLOCK_STR)
    {
      scene_text += pov_color;
      scene_text += "_rotate_counterclockwise";
    }
    else if(reactor_things_array[loop].object_type === SENS_REDIR_STR)
    {
      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: redirection direction problem");
        error_write("redirection direction problem");
        return "";
      }
      if((reactor_things_array[loop].atom < 1) ||
        (reactor_things_array[loop].atom > 113) ||
        (reactor_things_array[loop].atom != Math.round(reactor_things_array[loop].atom)))
      {
        // console_write("Error: redirection atomic number problem");
        error_write("redirection atomic number problem");
        return "";
      }
      scene_text += pov_color + "_";
      if(reactor_things_array[loop].atom === 110) scene_text += "Delta";
      else if(reactor_things_array[loop].atom === 111) scene_text += "Theta";
      else if(reactor_things_array[loop].atom === 112) scene_text += "Sigma";
      else if(reactor_things_array[loop].atom === 113) scene_text += "Omega";
      else scene_text += atom_abbrevs[reactor_things_array[loop].atom];
      scene_text += "_sensor";
    }
    else if(reactor_things_array[loop].object_type === FUSE_STR)
    {
      scene_text += pov_color + "_fuse";
    }
    else if(reactor_things_array[loop].object_type === SPLIT_STR)
    {
      scene_text += pov_color + "_split";
    }
    else if(reactor_things_array[loop].object_type === FLIP_FLOP_STR)
    {
      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: flip flop direction problem");
        error_write("flip flop direction problem");
        return "";
      }

      // gonna have to remove or change this later... and the sensor above...
      // since they're animated things that can change depending on what happens
      // in the reaction
      scene_text += pov_color + "_flip_flop_off_flip";
    }
    else if(reactor_things_array[loop].object_type === SWAP_STR)
    {
      scene_text += pov_color + "_swap";
    }

    // translate it back to origin, then to position
    scene_text += " translate <-0.5, -0.5, 0> translate ";
    scene_text += origin_to_position_translates[reactor_things_array[loop].location];
    scene_text += "}\n";
  }

  // now the tracks!
  scene_text += "\n";

  // track building strategy: start from one square past the starts and build
  // in a straight line until hitting the wall or a directional control.  If
  // it's the wall, add one more piece out of bounds to account for the
  // red/blue offset from center.  If it's a directional control, the last piece
  // should account for which direction that control leaves the square.  Then
  // continue from one past that control.  Keep track of which controls we've
  // already hit.  When we come back to one we've already hit, stop.
  // Then move on to things like sensor redirectors and flip flops -- the
  // controls that can override regular directional controls.  We will have
  // recorded which of these instructions we hit while following the directional
  // controls.  Start them with half-track pieces, then build as before.  Do
  // not stop if we come to an instruction control we've already hit.  Add it
  // to the controls_to_process array, if necessary, though.

  for(loop = 0; loop < 2; ++loop)  // loop so as not to write it all twice
  {
    if(loop === 0) which_color_this_time = RED_STR;
    else which_color_this_time = BLUE_STR;

    directions_to_process.length = 0;
    directions_already_processed.length = 0;
    controls_to_process.length = 0;
    controls_already_processed.length = 0;

    // find this color's start
    where_are_we_now = 0;
    for(moreloop = 0; moreloop < reactor_things_array.length; ++moreloop)
    {
      if((reactor_things_array[moreloop].object_type === START_STR) &&
        (reactor_things_array[moreloop].color === which_color_this_time))
      {
        where_are_we_now = reactor_things_array[moreloop].location;
        break;
      }
    }
    if(where_are_we_now === 0)
    {
      // console_write("Error: how'd we get this far without having that?");
      error_write("how'd we get this far without having that?");
      return "";
    }

    // push that start onto controls_to_process and let's begin
    controls_to_process.push(where_are_we_now);

    while((directions_to_process.length > 0) || (controls_to_process.length > 0))
    {
      which_way_are_we_going = "";
      // try the directions first
      if(directions_to_process.length > 0)
      {
        where_are_we_now = directions_to_process.shift();
        checking_controls = false;
        directions_already_processed.push(where_are_we_now);
      }
      else
      {
        where_are_we_now = controls_to_process.shift();
        checking_controls = true;
        controls_already_processed.push(where_are_we_now);
      }

      if(!validate_grid(where_are_we_now))
      {
        // console_write("Error: try to pin the blame on someone else and make sure your resume is up-to-date.");
        error_write("try to pin the blame on someone else and make sure your resume is up-to-date.");
        return "";
      }

      if(checking_controls)
      {
        // gonna have to find out the index of whatever control we're looking
        // at because we need to know what direction it's pointing... unless
        // this is a start control AND there is also a directional control on
        // this square -- in that case just use the directional control... by
        // which I mean just push the directional control onto the list to
        // check and let the loop check it
        useful_thing = what_stuff_is_at_place(which_color_this_time,
          where_are_we_now, false);
        if(useful_thing.length === 0)
        {
          // console_write("Error: whoops");
          error_write("whoops");
          return "";
        }
        if((useful_thing != SENS_REDIR_STR) && (useful_thing != START_STR) &&
          (useful_thing != FLIP_FLOP_STR))
        {
          // console_write("Error: clerical error");
          error_write("clerical error");
          return "";
        }

        if(useful_thing === START_STR)
        {
          // look for directional control -- if there is one, use that instead
          which_way_are_we_going = what_stuff_is_at_place(which_color_this_time,
            where_are_we_now, true);
          if(which_way_are_we_going.length > 0)
          {
            directions_to_process.push(where_are_we_now);
            continue;
          }
        }

        // not an else -- start instruction needs this if the if() above does
        // not hit the continue
        // so... look for this instruction in reactor_things_array
        which_way_are_we_going = "";
        for(moreloop = 0; moreloop < reactor_things_array.length; ++moreloop)
        {
          if((reactor_things_array[moreloop].object_type === useful_thing) &&
            (reactor_things_array[moreloop].location === where_are_we_now) &&
            (reactor_things_array[moreloop].color === which_color_this_time))
          {
            which_way_are_we_going = reactor_things_array[moreloop].direction;
            break;
          }
        }
        if(!validate_direction(which_way_are_we_going))
        {
          // console_write("Error: wandering");
          error_write("wandering");
          return "";
        }

        // and if this is not a start piece we'll need a half-track segment
        if(useful_thing != START_STR)
        {
          scene_text += "object {";
          if(which_color_this_time === RED_STR) scene_text += "red";
          else scene_text += "blue";
          scene_text += "_halftrack_";
          if(which_way_are_we_going === LEFT_STR) scene_text += "l";
          else if(which_way_are_we_going === RIGHT_STR) scene_text += "r";
          else if(which_way_are_we_going === UP_STR) scene_text += "u";
          else scene_text += "d";
          scene_text += " translate <-0.5, -0.5, 0> translate ";
          scene_text += origin_to_position_translates[where_are_we_now];
          scene_text += "}\n";
        }
      }
      else
      {
        // what_stuff_is_at_place() can tell us about this directional control
        which_way_are_we_going = what_stuff_is_at_place(which_color_this_time,
          where_are_we_now, true);
        if(!validate_direction(which_way_are_we_going))
        {
          // console_write("Error: there wasn\'t, but I could have sworn there was.");
          error_write("there wasn\'t, but I could have sworn there was.");
          return "";
        }
      }

      // now that we've established direction for whatever this is, let's start
      // drawing track
      // hey, I can finally use move_far()... for the direction parameter
      // rather than the far
      where_were_we_just_then = where_are_we_now;
      where_are_we_now = move_far(where_were_we_just_then, 1, which_way_are_we_going);
      if(where_are_we_now === 0)
      {
        // place an extra piece to make sure track extends to the edges
        scene_text += "object {";
        if(which_color_this_time === RED_STR) scene_text += "red_";
        else scene_text += "blue_";
        if(which_way_are_we_going === UP_STR)
        {
          scene_text += "ud translate <-0.5, 0.5, 0>";
        }
        else if(which_way_are_we_going === DOWN_STR)
        {
          scene_text += "ud translate <-0.5, -1.5, 0>";
        }
        else if(which_way_are_we_going === LEFT_STR)
        {
          scene_text += "lr translate <-1.5, -0.5, 0>";
        }
        else
        {
          scene_text += "lr translate <0.5, -0.5, 0>";
        }
        scene_text += " translate ";
        scene_text += origin_to_position_translates[where_were_we_just_then];
        scene_text += "}\n";
      }

      while(where_are_we_now != 0)
      {
        // check for instruction controls on this square
        useful_thing = what_stuff_is_at_place(which_color_this_time,
          where_are_we_now, false);
        if((useful_thing === SENS_REDIR_STR) || (useful_thing === FLIP_FLOP_STR))
        {
          // mark it down for later checking
          if(controls_already_processed.indexOf(where_are_we_now) === -1)
          {
            if(controls_to_process.indexOf(where_are_we_now) === -1)
            {
              controls_to_process.push(where_are_we_now);
            }
          }
        }

        // check for direction controls on this square
        useful_thing = what_stuff_is_at_place(which_color_this_time,
          where_are_we_now, true);
        if(useful_thing.length > 0)
        {
          // directional control -- figure out what shape track to put here,
          // add this location to controls to check, and end this iteration of
          // the loop
          if(!validate_direction(useful_thing))
          {
            // console_write("Error: oh, so that's how to factor large numbers efficiently.");
            error_write("oh, so that's how to factor large numbers efficiently.");
            return "";
          }

          // entry direction: which_way_are_we_going
          // exit direction: useful_thing
          scene_text += "object {";
          if(which_color_this_time === RED_STR) scene_text += "red_";
          else scene_text += "blue_";
          if(which_way_are_we_going === UP_STR)
          {
            if(useful_thing === UP_STR) scene_text += "ud";
            else if(useful_thing === DOWN_STR) scene_text += "loopback_d";
            else if(useful_thing === LEFT_STR) scene_text += "dl";
            else scene_text += "dr";
          }
          else if(which_way_are_we_going === DOWN_STR)
          {
            if(useful_thing === UP_STR) scene_text += "loopback_u";
            else if(useful_thing === DOWN_STR) scene_text += "ud";
            else if(useful_thing === LEFT_STR) scene_text += "ul";
            else scene_text += "ur";
          }
          else if(which_way_are_we_going === LEFT_STR)
          {
            if(useful_thing === UP_STR) scene_text += "ur";
            else if(useful_thing === DOWN_STR) scene_text += "dr";
            else if(useful_thing === LEFT_STR) scene_text += "lr";
            else scene_text += "loopback_r";
          }
          else
          {
            // entry going right
            if(useful_thing === UP_STR) scene_text += "ul";
            else if(useful_thing === DOWN_STR) scene_text += "dl";
            else if(useful_thing === LEFT_STR) scene_text += "loopback_l";
            else scene_text += "lr";
          }

          scene_text += " translate <-0.5, -0.5, 0> translate ";
          scene_text += origin_to_position_translates[where_are_we_now];
          scene_text += "}\n";

          // check and push
          if(directions_already_processed.indexOf(where_are_we_now) === -1)
          {
            if(directions_to_process.indexOf(where_are_we_now) === -1)
            {
              directions_to_process.push(where_are_we_now);
            }
          }
          // and tell the while loop that this track-laying part is done
          where_are_we_now = 0;
        }
        else
        {
          // no directional control -- place track in a straight line and try
          // to continue with the next square
          scene_text += "object {";
          if(which_color_this_time === RED_STR) scene_text += "red_";
          else scene_text += "blue_";
          if((which_way_are_we_going === UP_STR) || (which_way_are_we_going === DOWN_STR))
          {
            scene_text += "ud";
          }
          else
          {
            scene_text += "lr";
          }
          scene_text += " translate <-0.5, -0.5, 0> translate ";
          scene_text += origin_to_position_translates[where_are_we_now];
          scene_text += "}\n";

          // move one square in whatever direction we're going...
          where_were_we_just_then = where_are_we_now;
          where_are_we_now = move_far(where_were_we_just_then, 1, which_way_are_we_going);

          if(where_are_we_now === 0)
          {
            // we ran off the end of the grid -- place one more piece to be
            // sure the track reaches the wall
            scene_text += "object {";
            if(which_color_this_time === RED_STR) scene_text += "red_";
            else scene_text += "blue_";
            if(which_way_are_we_going === UP_STR)
            {
              scene_text += "ud translate <-0.5, 0.5, 0>";
            }
            else if(which_way_are_we_going === DOWN_STR)
            {
              scene_text += "ud translate <-0.5, -1.5, 0>";
            }
            else if(which_way_are_we_going === LEFT_STR)
            {
              scene_text += "lr translate <-1.5, -0.5, 0>";
            }
            else
            {
              scene_text += "lr translate <0.5, -0.5, 0>";
            }
            scene_text += " translate ";
            scene_text += origin_to_position_translates[where_were_we_just_then];
            scene_text += "}\n";
          }
        }
      }  // end of while(where_are_we_now != 0)
    }  // end of while at least one array isn't empty
  }  // end of for loop so that I don't have to write this twice

  // now the labels off to the sides
  // (reminder: have a use_big_psi bool from the top of this monstrosity)

  // alpha
  use_x1 = false;
  use_x2 = false;
  use_x3 = false;
  molecule_x1.length = 0;
  molecule_x2.length = 0;
  molecule_x3.length = 0;
  how_many = 3;

  for(loop = 0; loop < alpha_sequence_array.length; ++loop)
  {
    if(alpha_sequence_array[loop] === "A1") use_x1 = true;
    else if(alpha_sequence_array[loop] === "A2") use_x2 = true;
    else if(alpha_sequence_array[loop] === "A3") use_x3 = true;
  }

  if(use_x1 && (molecule_a1.length > 0))
  {
    for(loop = 0; loop < molecule_a1.length; ++loop)
    {
      molecule_x1.push(molecule_a1[loop].new_copy());
    }
  }
  else --how_many;

  if(use_x2 && (molecule_a2.length > 0))
  {
    for(loop = 0; loop < molecule_a2.length; ++loop)
    {
      if(how_many === 2) molecule_x1.push(molecule_a2[loop].new_copy());
      else molecule_x2.push(molecule_a2[loop].new_copy());
    }
  }
  else --how_many;

  if(use_x3 && (molecule_a3.length > 0))
  {
    for(loop = 0; loop < molecule_a3.length; ++loop)
    {
      if(how_many === 1) molecule_x1.push(molecule_a3[loop].new_copy());
      else if(how_many === 2) molecule_x2.push(molecule_a3[loop].new_copy());
      else molecule_x3.push(molecule_a3[loop].new_copy());
    }
  }
  else --how_many;

  if(how_many > 0)
  {
    if(molecule_x1.length > 0)
    {
      label_1_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x1.length; ++loop)
      {
        label_1_pov += "  object {";
        label_1_pov += atom_pov_abbrev(molecule_x1[loop].atomic_number);
        label_1_pov += "_atom translate ";
        label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
        label_1_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x1[loop].bond_right > 0)
        {
          label_1_pov += "  object {";
          if(molecule_x1[loop].bond_right === 1) label_1_pov += "single";
          else if(molecule_x1[loop].bond_right === 2) label_1_pov += "double";
          else label_1_pov += "triple";
          label_1_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
          label_1_pov += "}\n";
        }
        if(molecule_x1[loop].bond_down > 0)
        {
          label_1_pov += "  object {";
          if(molecule_x1[loop].bond_down === 1) label_1_pov += "single";
          else if(molecule_x1[loop].bond_down === 2) label_1_pov += "double";
          else label_1_pov += "triple";
          label_1_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
          label_1_pov += "}\n";
        }
      }
    }

    if(molecule_x2.length > 0)
    {
      label_2_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x2.length; ++loop)
      {
        label_2_pov += "  object {";
        label_2_pov += atom_pov_abbrev(molecule_x2[loop].atomic_number);
        label_2_pov += "_atom translate ";
        label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
        label_2_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x2[loop].bond_right > 0)
        {
          label_2_pov += "  object {";
          if(molecule_x2[loop].bond_right === 1) label_2_pov += "single";
          else if(molecule_x2[loop].bond_right === 2) label_2_pov += "double";
          else label_2_pov += "triple";
          label_2_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
          label_2_pov += "}\n";
        }
        if(molecule_x2[loop].bond_down > 0)
        {
          label_2_pov += "  object {";
          if(molecule_x2[loop].bond_down === 1) label_2_pov += "single";
          else if(molecule_x2[loop].bond_down === 2) label_2_pov += "double";
          else label_2_pov += "triple";
          label_2_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
          label_2_pov += "}\n";
        }
      }
    }

    if(molecule_x3.length > 0)
    {
      label_3_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x3.length; ++loop)
      {
        label_3_pov += "  object {";
        label_3_pov += atom_pov_abbrev(molecule_x3[loop].atomic_number);
        label_3_pov += "_atom translate ";
        label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
        label_3_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x3[loop].bond_right > 0)
        {
          label_3_pov += "  object {";
          if(molecule_x3[loop].bond_right === 1) label_3_pov += "single";
          else if(molecule_x3[loop].bond_right === 2) label_3_pov += "double";
          else label_3_pov += "triple";
          label_3_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
          label_3_pov += "}\n";
        }
        if(molecule_x3[loop].bond_down > 0)
        {
          label_3_pov += "  object {";
          if(molecule_x3[loop].bond_down === 1) label_3_pov += "single";
          else if(molecule_x3[loop].bond_down === 2) label_3_pov += "double";
          else label_3_pov += "triple";
          label_3_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
          label_3_pov += "}\n";
        }
      }
    }

  }  // end of if(how_many > 0)

  if(how_many === 1)
  {
    label_1_pov += "  scale (19/36) * 0.95 translate <-(109/18), 2, label_grid_layer>\n}\n";
    scene_text += label_1_pov;
  }
  else if(how_many === 2)
  {
    label_1_pov += "  scale 0.5 * 0.95 translate <-(109/18), 3, label_grid_layer>\n}\n";
    label_2_pov += "  scale 0.5 * 0.95 translate <-(109/18), 1, label_grid_layer>\n}\n";
    scene_text += label_1_pov + label_2_pov;
  }
  else if(how_many === 3)
  {
    label_1_pov += "  scale (1/3) * 0.95 translate <-(109/18), (10/3), label_grid_layer>\n}\n";
    label_2_pov += "  scale (1/3) * 0.95 translate <-(109/18), (6/3), label_grid_layer>\n}\n";
    label_3_pov += "  scale (1/3) * 0.95 translate <-(109/18), (2/3), label_grid_layer>\n}\n";
    scene_text += label_1_pov + label_2_pov + label_3_pov;
  }

  // beta... these are kinda big
  use_x1 = false;
  use_x2 = false;
  use_x3 = false;
  molecule_x1.length = 0;
  molecule_x2.length = 0;
  molecule_x3.length = 0;
  how_many = 3;

  for(loop = 0; loop < beta_sequence_array.length; ++loop)
  {
    if(beta_sequence_array[loop] === "B1") use_x1 = true;
    else if(beta_sequence_array[loop] === "B2") use_x2 = true;
    else if(beta_sequence_array[loop] === "B3") use_x3 = true;
  }

  if(use_x1 && (molecule_b1.length > 0))
  {
    for(loop = 0; loop < molecule_b1.length; ++loop)
    {
      molecule_x1.push(molecule_b1[loop].new_copy());
    }
  }
  else --how_many;

  if(use_x2 && (molecule_b2.length > 0))
  {
    for(loop = 0; loop < molecule_b2.length; ++loop)
    {
      if(how_many === 2) molecule_x1.push(molecule_b2[loop].new_copy());
      else molecule_x2.push(molecule_b2[loop].new_copy());
    }
  }
  else --how_many;

  if(use_x3 && (molecule_b3.length > 0))
  {
    for(loop = 0; loop < molecule_b3.length; ++loop)
    {
      if(how_many === 1) molecule_x1.push(molecule_b3[loop].new_copy());
      else if(how_many === 2) molecule_x2.push(molecule_b3[loop].new_copy());
      else molecule_x3.push(molecule_b3[loop].new_copy());
    }
  }
  else --how_many;

  if(how_many > 0)
  {
    if(molecule_x1.length > 0)
    {
      label_1_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x1.length; ++loop)
      {
        label_1_pov += "  object {";
        label_1_pov += atom_pov_abbrev(molecule_x1[loop].atomic_number);
        label_1_pov += "_atom translate ";
        label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
        label_1_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x1[loop].bond_right > 0)
        {
          label_1_pov += "  object {";
          if(molecule_x1[loop].bond_right === 1) label_1_pov += "single";
          else if(molecule_x1[loop].bond_right === 2) label_1_pov += "double";
          else label_1_pov += "triple";
          label_1_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
          label_1_pov += "}\n";
        }
        if(molecule_x1[loop].bond_down > 0)
        {
          label_1_pov += "  object {";
          if(molecule_x1[loop].bond_down === 1) label_1_pov += "single";
          else if(molecule_x1[loop].bond_down === 2) label_1_pov += "double";
          else label_1_pov += "triple";
          label_1_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_1_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x1[loop].position]];
          label_1_pov += "}\n";
        }
      }
    }

    if(molecule_x2.length > 0)
    {
      label_2_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x2.length; ++loop)
      {
        label_2_pov += "  object {";
        label_2_pov += atom_pov_abbrev(molecule_x2[loop].atomic_number);
        label_2_pov += "_atom translate ";
        label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
        label_2_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x2[loop].bond_right > 0)
        {
          label_2_pov += "  object {";
          if(molecule_x2[loop].bond_right === 1) label_2_pov += "single";
          else if(molecule_x2[loop].bond_right === 2) label_2_pov += "double";
          else label_2_pov += "triple";
          label_2_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
          label_2_pov += "}\n";
        }
        if(molecule_x2[loop].bond_down > 0)
        {
          label_2_pov += "  object {";
          if(molecule_x2[loop].bond_down === 1) label_2_pov += "single";
          else if(molecule_x2[loop].bond_down === 2) label_2_pov += "double";
          else label_2_pov += "triple";
          label_2_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_2_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x2[loop].position]];
          label_2_pov += "}\n";
        }
      }
    }

    if(molecule_x3.length > 0)
    {
      label_3_pov = "union\n{\n  object {label_box}\n";
      for(loop = 0; loop < molecule_x3.length; ++loop)
      {
        label_3_pov += "  object {";
        label_3_pov += atom_pov_abbrev(molecule_x3[loop].atomic_number);
        label_3_pov += "_atom translate ";
        label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
        label_3_pov += " translate <0, 0, -0.3>}\n";
        if(molecule_x3[loop].bond_right > 0)
        {
          label_3_pov += "  object {";
          if(molecule_x3[loop].bond_right === 1) label_3_pov += "single";
          else if(molecule_x3[loop].bond_right === 2) label_3_pov += "double";
          else label_3_pov += "triple";
          label_3_pov += "_bond translate <0.5, 0, -0.3> translate ";
          label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
          label_3_pov += "}\n";
        }
        if(molecule_x3[loop].bond_down > 0)
        {
          label_3_pov += "  object {";
          if(molecule_x3[loop].bond_down === 1) label_3_pov += "single";
          else if(molecule_x3[loop].bond_down === 2) label_3_pov += "double";
          else label_3_pov += "triple";
          label_3_pov += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
          label_3_pov += origin_to_position_translates[label_grid_to_real_grid[molecule_x3[loop].position]];
          label_3_pov += "}\n";
        }
      }
    }

  }  // end of if(how_many > 0)

  if(how_many === 1)
  {
    label_1_pov += "  scale (19/36) * 0.95 translate <-(109/18), -2, label_grid_layer>\n}\n";
    scene_text += label_1_pov;
  }
  else if(how_many === 2)
  {
    label_1_pov += "  scale 0.5 * 0.95 translate <-(109/18), -1, label_grid_layer>\n}\n";
    label_2_pov += "  scale 0.5 * 0.95 translate <-(109/18), -3, label_grid_layer>\n}\n";
    scene_text += label_1_pov + label_2_pov;
  }
  else if(how_many === 3)
  {
    label_1_pov += "  scale (1/3) * 0.95 translate <-(109/18), -(2/3), label_grid_layer>\n}\n";
    label_2_pov += "  scale (1/3) * 0.95 translate <-(109/18), -(6/3), label_grid_layer>\n}\n";
    label_3_pov += "  scale (1/3) * 0.95 translate <-(109/18), -(10/3), label_grid_layer>\n}\n";
    scene_text += label_1_pov + label_2_pov + label_3_pov;
  }

  // Remember when I wrote the use_big_psi bool reminder and called the
  // function at that point a monstrosity?  Good times.

  // anyway, psi now

  // start by verifying that the molecule fits into the small label, if needed
  if(!use_big_psi)
  {
    for(loop = 0; loop < molecule_psi_label.length; ++loop)
    {
      if(molecule_psi_label[loop].position > 16)
      {
        // console_write("Error: label for output \u03c8 is too large for a standard label -- make a smaller label or choose large output \u03c8.");
        error_write("label for output \u03c8 is too large for a standard label -- make a smaller label or choose large output \u03c8.");
        // ref.value = "";
        return "";
      }
    }
  }

  // there -- whatever label and molecule we're using, it fits

  // do big psi first because standard psi will have omega, too
  if(use_big_psi)
  {
    for(loop = 0; loop < molecule_psi_label.length; ++loop)
    {
      if(loop === 0)
      {
        // inside the loop so that the box only appears if label is present
        scene_text += "union\n{\n  object {label_box translate <0, 2, 0>}\n";
        scene_text += "  object {label_box translate <0, -2, 0>}\n";
      }

      scene_text += "  object {";
      scene_text += atom_pov_abbrev(molecule_psi_label[loop].atomic_number);
      scene_text += "_atom translate <0, 0, -0.3> translate ";
      scene_text += origin_to_position_translates[big_label_grid_to_real_grid[molecule_psi_label[loop].position]];
      scene_text += "}\n";
      if(molecule_psi_label[loop].bond_right > 0)
      {
        scene_text += "  object {";
        if(molecule_psi_label[loop].bond_right === 1) scene_text += "single";
        else if(molecule_psi_label[loop].bond_right === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> translate ";
        scene_text += origin_to_position_translates[big_label_grid_to_real_grid[molecule_psi_label[loop].position]];
        scene_text += "}\n";
      }
      if(molecule_psi_label[loop].bond_down > 0)
      {
        scene_text += "  object {";
        if(molecule_psi_label[loop].bond_down === 1) scene_text += "single";
        else if(molecule_psi_label[loop].bond_down === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
        scene_text += origin_to_position_translates[big_label_grid_to_real_grid[molecule_psi_label[loop].position]];
        scene_text += "}\n";
      }

      if(loop === (molecule_psi_label.length - 1))
      {
        scene_text += "  scale (19/36) * 0.95 translate <(109/18), 0, label_grid_layer>\n}\n";
      }
    }
  }
  else
  {
    // standard psi
    for(loop = 0; loop < molecule_psi_label.length; ++loop)
    {
      if(loop === 0)
      {
        scene_text += "union\n{\n  object {label_box}\n";
      }

      scene_text += "  object {";
      scene_text += atom_pov_abbrev(molecule_psi_label[loop].atomic_number);
      scene_text += "_atom translate <0, 0, -0.3> translate ";
      scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_psi_label[loop].position]];
      scene_text += "}\n";
      if(molecule_psi_label[loop].bond_right > 0)
      {
        scene_text += "  object {";
        if(molecule_psi_label[loop].bond_right === 1) scene_text += "single";
        else if(molecule_psi_label[loop].bond_right === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> translate ";
        scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_psi_label[loop].position]];
        scene_text += "}\n";
      }
      if(molecule_psi_label[loop].bond_down > 0)
      {
        scene_text += "  object {";
        if(molecule_psi_label[loop].bond_down === 1) scene_text += "single";
        else if(molecule_psi_label[loop].bond_down === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
        scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_psi_label[loop].position]];
        scene_text += "}\n";
      }

      if(loop === (molecule_psi_label.length - 1))
      {
        scene_text += "  scale (19/36) * 0.95 translate <(109/18), 2, label_grid_layer>\n}\n";
      }
    }

    // omega
    for(loop = 0; loop < molecule_omega_label.length; ++loop)
    {
      if(loop === 0)
      {
        scene_text += "union\n{\n  object {label_box}\n";
      }

      scene_text += "  object {";
      scene_text += atom_pov_abbrev(molecule_omega_label[loop].atomic_number);
      scene_text += "_atom translate <0, 0, -0.3> translate ";
      scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_omega_label[loop].position]];
      scene_text += "}\n";
      if(molecule_omega_label[loop].bond_right > 0)
      {
        scene_text += "  object {";
        if(molecule_omega_label[loop].bond_right === 1) scene_text += "single";
        else if(molecule_omega_label[loop].bond_right === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> translate ";
        scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_omega_label[loop].position]];
        scene_text += "}\n";
      }
      if(molecule_omega_label[loop].bond_down > 0)
      {
        scene_text += "  object {";
        if(molecule_omega_label[loop].bond_down === 1) scene_text += "single";
        else if(molecule_omega_label[loop].bond_down === 2) scene_text += "double";
        else scene_text += "triple";
        scene_text += "_bond translate <0.5, 0, -0.3> rotate -90 * z translate ";
        scene_text += origin_to_position_translates[label_grid_to_real_grid[molecule_omega_label[loop].position]];
        scene_text += "}\n";
      }

      if(loop === (molecule_omega_label.length - 1))
      {
        scene_text += "  scale (19/36) * 0.95 translate <(109/18), -2, label_grid_layer>\n}\n";
      }
    }
  }

  // ref.value = scene_text;
  return scene_text;
}

function generate_preview_fn()
{
  var loop;
  var ini_ref;
  var scene_ref;
  var scene_text;

  ini_ref = document.getElementById("preview_ini_output");
  scene_ref = document.getElementById("preview_scene_output");
  if((ini_ref == null) || (scene_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  scene_text = generate_reactor_statics();
  if(scene_text.length === 0)
  {
    // some error or other -- console will have been updated by that function
    return;
  }

  // now draw static versions of the flip flops and sensor redirects
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].object_type === SENS_REDIR_STR) ||
      (reactor_things_array[loop].object_type === FLIP_FLOP_STR))
    {
      // the usual paperwork
      if(!validate_grid(reactor_things_array[loop].location))
      {
        // console_write("Error: bad grid location");
        error_write("bad grid location");
        return;
      }
      if(!validate_color(reactor_things_array[loop].color))
      {
        // console_write("Error: bad color");
        error_write("bad color");
        return;
      }
      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: bad direction");
        error_write("bad direction");
        return;
      }

      // looks good, just one more thing to check in the sensor section...
      if(reactor_things_array[loop].object_type === SENS_REDIR_STR)
      {
        if((isNaN(reactor_things_array[loop].atom)) ||
          (reactor_things_array[loop].atom < 1) ||
          (reactor_things_array[loop].atom > 113) ||
          (Math.round(reactor_things_array[loop].atom) != reactor_things_array[loop].atom))
        {
          // console_write("Error: bad atomic number");
          error_write("bad atomic number");
          return;
        }

        scene_text += "object {";
        if(reactor_things_array[loop].color === RED_STR) scene_text += "red_";
        else scene_text += "blue_";
        scene_text += atom_pov_abbrev(reactor_things_array[loop].atom);
        scene_text += "_sensor_inactive translate <-0.5, -0.5, 0> translate ";
        scene_text += origin_to_position_translates[reactor_things_array[loop].location];
        scene_text += "}\n";
      }
      else
      {
        // flip flop
        scene_text += "object {";
        if(reactor_things_array[loop].color === RED_STR) scene_text += "red";
        else scene_text += "blue";
        scene_text += "_flip_flop_off_flip translate <-0.5, -0.5, 0> translate ";
        scene_text += origin_to_position_translates[reactor_things_array[loop].location];
        scene_text += "}\n";
      }

      // and they both need the little gray arrow
      scene_text += "object {";
      if(reactor_things_array[loop].color === RED_STR) scene_text += "red";
      else scene_text += "blue";
      scene_text += "_indicator_";
      if(reactor_things_array[loop].direction === RIGHT_STR) scene_text += "r";
      else if(reactor_things_array[loop].direction === LEFT_STR) scene_text += "l";
      else if(reactor_things_array[loop].direction === UP_STR) scene_text += "u";
      else scene_text += "d";
      scene_text += " translate <-0.5, -0.5, 0> translate ";
      scene_text += origin_to_position_translates[reactor_things_array[loop].location];
      scene_text += "}\n";
    }
  }

  scene_ref.value = scene_text;

  // and then the .ini
  scene_text = "[Preview 1280x720]\nQuality=9\nAntialias_Depth=5\n";
  scene_text += "Antialias=On\nAntialias_Threshold=0.05\nJitter=Off\n";
  scene_text += "+W1280 +H720\n\n";

  scene_text += "[Preview 1920x1080]\nQuality=9\nAntialias_Depth=5\n";
  scene_text += "Antialias=On\nAntialias_Threshold=0.05\nJitter=Off\n";
  scene_text += "+W1920 +H1080\n\n";

  scene_text += "[Preview 4K (3840x2160)]\nQuality=9\nAntialias_Depth=5\n";
  scene_text += "Antialias=On\nAntialias_Threshold=0.05\nJitter=Off\n";
  scene_text += "+W3840 +H2160\n";

  ini_ref.value = scene_text;

  console_write("Generated preview scene and .ini.");
}

// I'm tired of doing a bunch of if()s every time I need the slightly
// different format for the special elements
function atom_pov_abbrev(atomic_number)
{
  if((isNaN(atomic_number)) || (atomic_number < 1) || (atomic_number > 113) ||
    (Math.round(atomic_number) != atomic_number))
  {
    // console_write("Error: bad atomic number");
    error_write("bad atomic number");
    return "";
  }

  if(atomic_number === 110) return "Delta";
  if(atomic_number === 111) return "Theta";
  if(atomic_number === 112) return "Sigma";
  if(atomic_number === 113) return "Omega";
  return atom_abbrevs[atomic_number];
}

// I've decided I should be able to click on cells to set them as the current
// grid position in the object placement thing
function grid_click_handler(who)
{
  var ref;
  var thing;

  ref = document.getElementById("input_grid_number");
  if(ref == null)
  {
    // console_write("Error: it\'s shy");
    error_write("it\'s shy");
    return;
  }

  thing = who.innerHTML;
  ref.value = thing;

  // this apparently doesn't trigger input or change events, so...
  number_prettifier();

  // hide the grid clear confirmation in case it was left open
  ref = document.getElementById("clear_confirm_div");
  if(ref == null)
  {
    error_write("well hekkit.");
    return;
  }
  ref.setAttribute("hidden", "");
}


// I'm also tired of having to re-write this loop every time I need the index
// of a control at a particular place
// where: position on the reactor grid
// what_color: either RED_STR or BLUE_STR; no other valid values
// dir_bool: false -- look for instruction controls; true -- look for
//   direction controls
// returns a valid index into reactor_things_array, or -1 if not found or if
//   there was some other error
function get_thing_index(where, what_color, dir_bool)
{
  var loop;

  if(!validate_grid(where)) return -1;
  if(!validate_color(what_color)) return -1;
  if(typeof(dir_bool) != typeof(false)) return -1;

  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if(dir_bool)
    {
      if(reactor_things_array[loop].object_type != WALDO_DIR_STR) continue;
    }
    else
    {
      if(reactor_things_array[loop].object_type === WALDO_DIR_STR) continue;
    }

    if(reactor_things_array[loop].location != where) continue;
    if(reactor_things_array[loop].color != what_color) continue;

    // it's a match!
    return loop;
  }

  return -1;
}


// the last of the paperwork functions... until I think up more
function select_preview_ini_fn()
{
  var ref;
  ref = document.getElementById("preview_ini_output");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  ref.select();
}

function select_preview_scene_fn()
{
  var ref;
  ref = document.getElementById("preview_scene_output");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  ref.select();
}

function select_real_ini_fn()
{
  var ref;
  ref = document.getElementById("real_ini_output");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  ref.select();
}

function select_real_scene_fn()
{
  var ref;
  ref = document.getElementById("real_scene_output");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  ref.select();
}


// I guess the best way to keep track of a waldo would be an object for it
function waldo()
{
  this.position = 0;
  this.direction = "";
  this.hold_atom = false;
  this.proceed = true;  // false to hold in place for syncs, rotates, walls...
  this.current_cycle = 0;
  this.prev_position = 0;
  this.last_cycle_was_rotate = false;
}


// well, no more putting it off -- the reaction simulation function
function holy_crap_here_we_go()
{
  var loop;
  var moreloop;
  var yetmoreloop;
  var hard_cycle_limit = 10000;
  var current_cycle;

  // var red_waldo;
  // var blue_waldo;
  var the_waldos = [];  // 0 red, 1 blue
  var waldo_loop;

  var psi_count;
  var omega_count;

  var PSI_LIMIT = "psi_limit";
  var OMEGA_LIMIT = "omega_limit";
  var CYCLE_LIMIT = "cycle_limit";
  var limit_type;  // equals one of those
  var limit_count;
  var extra_cycles;
  var frames_per_cycle;

  var ref;
  var ini_ref;
  var scene_ref;
  var text;
  var error_text;  // and hopefully we won't have to use this
  var provisional_text;  // write to here until we're sure there isn't an error
  var sfx_text;  // special effects... append to text if it all works

  var useful_thing;
  var more_useful;
  var color_this_time;

  var use_big_psi;
  var main_limit_end_cycle = 0;
  var needs_an_end = false;

  var alpha_to_grid = [0,
    1,  2,  3,  4,
    11, 12, 13, 14,
    21, 22, 23, 24,
    31, 32, 33, 34];

  var beta_to_grid = [0,
    41, 42, 43, 44,
    51, 52, 53, 54,
    61, 62, 63, 64,
    71, 72, 73, 74];

  var psi_region = [
    7,  8,  9,  10,
    17, 18, 19, 20,
    27, 28, 29, 30,
    37, 38, 39, 40];

  var omega_region = [
    47, 48, 49, 50,
    57, 58, 59, 60,
    67, 68, 69, 70,
    77, 78, 79, 80];

  var big_psi_region = [
    7,  8,  9,  10,
    17, 18, 19, 20,
    27, 28, 29, 30,
    37, 38, 39, 40,
    47, 48, 49, 50,
    57, 58, 59, 60,
    67, 68, 69, 70,
    77, 78, 79, 80];

  var check_grid = [];
  var check_progress;

  var one_spot;
  var other_spot;
  var one_atom;
  var other_atom;

  var ultrabreak = false;

  var claimed = [];

  var at_least_one_alpha = false;
  var at_least_one_beta = false;
  var alpha_sequence_index = 0;
  var beta_sequence_index = 0;
  var insert_molecule = [];
  var still_looking;

  var fiss_newguy;

  var swap_beam;
  var flash_tunnel_one;
  var flash_tunnel_other;

  var mini_color;

  var axis_vertical;
  var axis_horizontal;  // distances to axis from some spot

  // let's start the preliminary paperwork

  ini_ref = document.getElementById("real_ini_output");
  if(ini_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  scene_ref = document.getElementById("real_scene_output");
  if(scene_ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }

  ref = document.getElementById("big_psi_select");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  if(ref.selectedIndex === 0) use_big_psi = false;
  else if(ref.selectedIndex === 1) use_big_psi = true;
  else
  {
    // console_write("Error: didn't expect that");
    error_write("didn't expect that");
    return;
  }

  ref = document.getElementById("how_long_to_run");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  if(ref.selectedIndex === 0) limit_type = PSI_LIMIT;
  else if(ref.selectedIndex === 1) limit_type = OMEGA_LIMIT;
  else if(ref.selectedIndex === 2) limit_type = CYCLE_LIMIT;
  else
  {
    // console_write("Error: unexpected value from \"how_long_to_run\" drop-down");
    error_write("unexpected value from \"how_long_to_run\" drop-down");
    return;
  }

  if((limit_type === OMEGA_LIMIT) && use_big_psi)
  {
    // console_write("Error: can't count output \u03c9 when only output is large \u03c8.  Select a different reaction limit or choose standard \u03c8 and \u03c9 outputs.");
    error_write("can't count output \u03c9 when only output is large \u03c8.  Select a different reaction limit or choose standard \u03c8 and \u03c9 outputs.");
    return;
  }

  ref = document.getElementById("input_reaction_limit");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  limit_count = Number(ref.value);
  if((isNaN(limit_count)) || (limit_count < 1) || (limit_count > 10000) ||
    (Math.round(limit_count) != limit_count))
  {
    // console_write("Error: bad value from \"input_reaction_limit\" input field");
    error_write("bad value from \"input_reaction_limit\" input field");
    return;
  }

  ref = document.getElementById("input_reaction_extra_cycles");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  extra_cycles = Number(ref.value);
  if((isNaN(extra_cycles)) || (extra_cycles < 0) || (extra_cycles > 100) ||
    (Math.round(extra_cycles) != extra_cycles))
  {
    // console_write("Error: bad value from \"input_reaction_extra_cycles\" input field");
    error_write("bad value from \"input_reaction_extra_cycles\" input field");
    return;
  }

  ref = document.getElementById("input_frames_per_cycle");
  if(ref == null)
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  frames_per_cycle = Number(ref.value);
  if((isNaN(frames_per_cycle)) || (frames_per_cycle < 1) ||
    (Math.round(frames_per_cycle) != frames_per_cycle))
  {
    // console_write("Error: bad value from frames-per-cycle input field");
    error_write("bad value from frames-per-cycle input field");
    return;
  }

  if(frames_per_cycle > 60)  // ... let's say
  {
    // console_write("Warning: " + frames_per_cycle + " frames per cycle seems like a lot.  Are you sure that's right?");
    warning_write("" + frames_per_cycle + " frames per cycle seems like a lot.  Are you sure that's right?");
  }

  // red_waldo = new waldo();
  the_waldos.push(new waldo());
  // blue_waldo = new waldo();
  the_waldos.push(new waldo());

  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if(reactor_things_array[loop].object_type === START_STR)
    {
      if(reactor_things_array[loop].color === RED_STR)
      {
        the_waldos[0].position = reactor_things_array[loop].location;
        the_waldos[0].direction = reactor_things_array[loop].direction;
      }
      else if(reactor_things_array[loop].color === BLUE_STR)
      {
        the_waldos[1].position = reactor_things_array[loop].location;
        the_waldos[1].direction = reactor_things_array[loop].direction
      }
      else
      {
        // console_write("Error: welp");
        error_write("welp");
        return;
      }
    }
  }

  // some sanity checks

  // waldo positions
  if((!validate_grid(the_waldos[0].position)) ||
    (!validate_grid(the_waldos[1].position)))
  {
    // console_write("Error during reaction initialization");
    error_write("Error during reaction initialization");
    return;
  }

  // reactor devices
  for(loop = 0; loop < bonder_spots.length; ++loop)
  {
    if(!validate_grid(bonder_spots[loop]))
    {
      // console_write("Error: bonder out of bounds... probably my fault, sorry");
      error_write("bonder out of bounds... probably my fault, sorry");
      return;
    }
    if(claimed.indexOf(bonder_spots[loop]) != -1)
    {
      // console_write("Error: two bonders on the same spot somehow... probably my fault, sorry");
      error_write("two bonders on the same spot somehow... probably my fault, sorry");
      return;
    }
    claimed.push(bonder_spots[loop]);
  }

  if(sensor_spot != 0)
  {
    if(!validate_grid(sensor_spot))
    {
      // console_write("Error: invalid sensor position... probably my fault, sorry");
      error_write("invalid sensor position... probably my fault, sorry");
      return;
    }
    if(claimed.indexOf(sensor_spot) != -1)
    {
      // console_write("Error: sensor and a bonder on the same position somehow... probably my fault, sorry");
      error_write("sensor and a bonder on the same position somehow... probably my fault, sorry");
      return;
    }
    claimed.push(sensor_spot);
  }

  if((fuse_left != 0) || (fuse_right != 0))
  {
    if(!(validate_grid(fuse_left) && validate_grid(fuse_right)))
    {
      // console_write("Error: fusion target out of bounds somehow... probably my fault, sorry");
      error_write("fusion target out of bounds somehow... probably my fault, sorry");
      return;
    }
    if(move_right(fuse_left) != fuse_right)
    {
      // console_write("Error: broken fusion target... probably my fault, sorry");
      error_write("broken fusion target... probably my fault, sorry");
      return;
    }
    if(claimed.indexOf(fuse_left) != -1)
    {
      // console_write("Error: fusion target overlaps something somehow... probably my fault, sorry");
      error_write("fusion target overlaps something somehow... probably my fault, sorry");
      return;
    }
    claimed.push(fuse_left);
    if(claimed.indexOf(fuse_right) != -1)
    {
      // console_write("Error: fusion target overlaps something somehow... probably my fault, sorry");
      error_write("fusion target overlaps something somehow... probably my fault, sorry");
      return;
    }
    claimed.push(fuse_right);
  }

  if((fiss_left != 0) || (fiss_right != 0))
  {
    if(!(validate_grid(fiss_left) && validate_grid(fiss_right)))
    {
      // console_write("Error: fission target out of bounds somehow... probably my fault, sorry");
      error_write("fission target out of bounds somehow... probably my fault, sorry");
      return;
    }
    if(move_right(fiss_left) != fiss_right)
    {
      // console_write("Error: broken fission target... probably my fault, sorry");
      error_write("broken fission target... probably my fault, sorry");
      return;
    }
    if(claimed.indexOf(fiss_left) != -1)
    {
      // console_write("Error: fisson target overlaps something somehow... probably my fault, sorry");
      error_write("fisson target overlaps something somehow... probably my fault, sorry");
      return;
    }
    claimed.push(fiss_left);
    if(claimed.indexOf(fiss_right) != -1)
    {
      // console_write("Error: fission target overlaps something somehow... probably my fault, sorry");
      error_write("fission target overlaps something somehow... probably my fault, sorry");
      return;
    }
    claimed.push(fiss_right)
  }

  if((tunnel_one != 0) || (tunnel_other != 0))
  {
    if(!(validate_grid(tunnel_one) && validate_grid(tunnel_other)))
    {
      if((validate_grid(tunnel_one) && (tunnel_other === 0)) ||
        (validate_grid(tunnel_other) && (tunnel_one === 0)))
      {
        // console_write("Error: only one quantum tunnel placed; solution must have 0 or 2.");
        error_write("only one quantum tunnel placed; solution must have 0 or 2.");
        return;
      }
      // console_write("Error: quantum tunnel out of bounds somehow... probably my fault, sorry");
      error_write("quantum tunnel out of bounds somehow... probably my fault, sorry");
      return;
    }
    if(claimed.indexOf(tunnel_one) != -1)
    {
      // console_write("Error: quantum tunnel overlaps something somehow... probably my fault, sorry");
      error_write("quantum tunnel overlaps something somehow... probably my fault, sorry");
      return;
    }
    claimed.push(tunnel_one);
    if(claimed.indexOf(tunnel_other) != -1)
    {
      // console_write("Error: quantum tunnel overlaps something somehow... probably my fault, sorry");
      error_write("quantum tunnel overlaps something somehow... probably my fault, sorry");
      return;
    }
  }

  // reaction instructions
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if(!validate_grid(reactor_things_array[loop].location))
    {
      // console_write("Error: instruction out of bounds... probably my fault, sorry");
      error_write("instruction out of bounds... probably my fault, sorry");
      return;
    }
    if(!validate_color(reactor_things_array[loop].color))
    {
      // console_write("Error: bad color... probably my fault, sorry");
      error_write("bad color... probably my fault, sorry");
      return;
    }
    if(controls.indexOf(reactor_things_array[loop].object_type) < 0)
    {
      // console_write("Error: unknown object type... probably my fault, sorry");
      error_write("unknown object type... probably my fault, sorry");
      return;
    }
    if((reactor_things_array[loop].object_type === WALDO_DIR_STR) ||
      (reactor_things_array[loop].object_type === SENS_REDIR_STR) ||
      (reactor_things_array[loop].object_type === FLIP_FLOP_STR))
    {
      if(!validate_direction(reactor_things_array[loop].direction))
      {
        // console_write("Error: bad direction... probably my fault, sorry");
        error_write("bad direction... probably my fault, sorry");
        return;
      }
      if(reactor_things_array[loop].object_type === SENS_REDIR_STR)
      {
        if((isNaN(reactor_things_array[loop].atom)) ||
          (reactor_things_array[loop].atom < 1) ||
          (reactor_things_array[loop].atom > 113) ||
          (Math.round(reactor_things_array[loop].atom) != reactor_things_array[loop].atom))
        {
          // console_write("Error: bad atomic number... probably my fault, sorry");
          error_write("bad atomic number... probably my fault, sorry");
          return;
        }
      }
    }
  }

  // red/blue direction overlaps
  claimed.length = 0;
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].object_type === WALDO_DIR_STR) &&
      (reactor_things_array[loop].color === RED_STR))
    {
      if(claimed.indexOf(reactor_things_array[loop].location) != -1)
      {
        // console_write("Error: two red directions overlap... probably my fault, sorry");
        error_write("two red directions overlap... probably my fault, sorry");
        return;
      }
      claimed.push(reactor_things_array[loop].location);
    }
  }

  claimed.length = 0;
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].object_type === WALDO_DIR_STR) &&
      (reactor_things_array[loop].color != RED_STR))
    {
      if(claimed.indexOf(reactor_things_array[loop].location) != -1)
      {
        // console_write("Error: two blue directions overlap... probably my fault, sorry");
        error_write("two blue directions overlap... probably my fault, sorry");
        return;
      }
      claimed.push(reactor_things_array[loop].location);
    }
  }

  // red/blue instruction overlaps
  claimed.length = 0;
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].object_type != WALDO_DIR_STR) &&
      (reactor_things_array[loop].color === RED_STR))
    {
      if(claimed.indexOf(reactor_things_array[loop].location) != -1)
      {
        // console_write("Error: two red instructions overlap... probably my fault, sorry");
        error_write("two red instructions overlap... probably my fault, sorry");
        return;
      }
      claimed.push(reactor_things_array[loop].location);
    }
  }

  claimed.length = 0;
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    if((reactor_things_array[loop].object_type != WALDO_DIR_STR) &&
      (reactor_things_array[loop].color != RED_STR))
    {
      if(claimed.indexOf(reactor_things_array[loop].location) != -1)
      {
        // console_write("Error: two blue instructions overlap... probably my fault, sorry");
        error_write("two blue instructions overlap... probably my fault, sorry");
        return;
      }
      claimed.push(reactor_things_array[loop].location);
    }
  }

  // alpha/beta input molecules and sequences
  for(loop = 0; loop < 6; ++loop)
  {
    check_grid.length = 0;
    if(loop === 0)
    {
      for(moreloop = 0; moreloop < molecule_a1.length; ++moreloop)
      {
        // inside the loop so that it only happens if this molecule is not empty
        if(alpha_sequence_array.indexOf("A1") >= 0) at_least_one_alpha = true;
        check_grid.push(molecule_a1[moreloop].new_copy());
      }
    }
    else if(loop === 1)
    {
      for(moreloop = 0; moreloop < molecule_a2.length; ++moreloop)
      {
        if(alpha_sequence_array.indexOf("A2") >= 0) at_least_one_alpha = true;
        check_grid.push(molecule_a2[moreloop].new_copy());
      }
    }
    else if(loop === 2)
    {
      for(moreloop = 0; moreloop < molecule_a3.length; ++moreloop)
      {
        if(alpha_sequence_array.indexOf("A3") >= 0) at_least_one_alpha = true;
        check_grid.push(molecule_a3[moreloop].new_copy());
      }
    }
    else if(loop === 3)
    {
      for(moreloop = 0; moreloop < molecule_b1.length; ++moreloop)
      {
        if(beta_sequence_array.indexOf("B1") >= 0) at_least_one_beta = true;
        check_grid.push(molecule_b1[moreloop].new_copy());
      }
    }
    else if(loop === 4)
    {
      for(moreloop = 0; moreloop < molecule_b2.length; ++moreloop)
      {
        if(beta_sequence_array.indexOf("B2") >= 0) at_least_one_beta = true;
        check_grid.push(molecule_b2[moreloop].new_copy());
      }
    }
    else
    {
      for(moreloop = 0; moreloop < molecule_b3.length; ++moreloop)
      {
        if(beta_sequence_array.indexOf("B3") >= 0) at_least_one_beta = true;
        check_grid.push(molecule_b3[moreloop].new_copy());
      }
    }

    // make sure no atoms in this molecule overlap
    for(moreloop = 0; moreloop < check_grid.length; ++moreloop)
    {
      for(yetmoreloop = 0; yetmoreloop < moreloop; ++yetmoreloop)
      {
        if(check_grid[moreloop].position === check_grid[yetmoreloop].position)
        {
          // console_write("Error: atom overlap in an input molecule... probably my fault, sorry");
          error_write("atom overlap in an input molecule... probably my fault, sorry");
          return;
        }
      }
    }
  }

  if(!(at_least_one_alpha || at_least_one_beta))
  {
    // console_write("Error: no input molecules");
    error_write("no input molecules");
    return;
  }

  for(loop = 0; loop < alpha_sequence_array.length; ++loop)
  {
    if((alpha_sequence_array[loop] != "A1") &&
      (alpha_sequence_array[loop] != "A2") &&
      (alpha_sequence_array[loop] != "A3"))
    {
      // console_write("Error: alpha sequence problem");
      error_write("alpha sequence problem");
      return;
    }
  }

  for(loop = 0; loop < beta_sequence_array.length; ++loop)
  {
    if((beta_sequence_array[loop] != "B1") &&
      (beta_sequence_array[loop] != "B2") &&
      (beta_sequence_array[loop] != "B3"))
    {
      // console_write("Error: beta sequence problem");
      error_write("beta sequence problem");
      return;
    }
  }

  // sanity checks passed

  text = generate_reactor_statics();

  if(text.length === 0)
  {
    // any error message would already be printed
    return;
  }

  // reaction statistics include some extra statics that aren't present in
  // the preview...
  text += "text {ttf \"cyrvetic.ttf\" \"Cycle:\" 0.1, 0 scale 0.3 translate <5.1, -3.4, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
  // text += "text {ttf \"times.ttf\" letter_psi 0.1, 0 scale 0.3 translate <5.1, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
  text += "text {ttf font_string letter_psi 0.1, 0 scale 0.3 translate <5.1, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
  text += "text {ttf \"cyrvetic.ttf\" \":\" 0.1, 0 scale 0.3 translate <5.31, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
  if(!use_big_psi)
  {
    // text += "text {ttf \"times.ttf\" letter_omega_small 0.1, 0 scale 0.3 translate <6, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
    text += "text {ttf font_string letter_omega_small 0.1, 0 scale 0.3 translate <6, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
    text += "text {ttf \"cyrvetic.ttf\" \":\" 0.1, 0 scale 0.3 translate <6.21, -3.75, label_grid_layer> texture {pigment {rgb 1} finish {ambient 1}} no_shadow}\n";
  }

  current_cycle = 0;
  psi_count = 0;
  omega_count = 0;
  reactor_atoms.length = 0;

  // reset any states from previous runs
  for(loop = 0; loop < reactor_things_array.length; ++loop)
  {
    reactor_things_array[loop].state = 0;
    reactor_things_array[loop].prev_state = 0;
  }

  console_write("Starting reaction simulation.");

  while(true)  // main reaction loop; will break to exit
  {
    // so let's see if we should break
    if(current_cycle > hard_cycle_limit)
    {
      // console_write("Warning: cycle limit reached.  Make sure your waldo programs are set correctly.");
      warning_write("Cycle limit reached.  Make sure your waldo programs are set correctly.");
      break;
    }
    if(limit_type === PSI_LIMIT)
    {
      if(psi_count >= limit_count)
      {
        if(main_limit_end_cycle === 0) main_limit_end_cycle = current_cycle;
        if((current_cycle - main_limit_end_cycle) >= extra_cycles) break;
      }
    }
    else if(limit_type === OMEGA_LIMIT)
    {
      if(omega_count >= limit_count)
      {
        if(main_limit_end_cycle === 0) main_limit_end_cycle = current_cycle;
        if((current_cycle - main_limit_end_cycle) >= extra_cycles) break;
      }
    }
    else if(limit_type === CYCLE_LIMIT)
    {
      if(current_cycle >= (limit_count + extra_cycles)) break;
    }
    else
    {
      // console_write("Error: now how the heck did that happen?");
      error_write("now how the heck did that happen?");
      return;
    }

    // check how all the atoms ended up -- if they all pass, then increment
    // cycle
    error_text = "// WARNING\n";
    error_text += "// This reaction ends in an error.\n";
    error_text += "// See the output log at the top of the PovChem page for details.\n\n";
    for(loop = 0; loop < reactor_atoms.length; ++loop)
    {
      // make sure they're all in-bounds...
      if(!validate_grid(reactor_atoms[loop].next_position))
      {
        text = (error_text + text);
        // console_write("Warning: reaction ends in an error: atom goes out-of-bounds from position " + reactor_atoms[loop].position + " on cycle " + current_cycle + ".");
        warning_write("Reaction ends in an error: atom goes out-of-bounds from position " + reactor_atoms[loop].position + " on cycle " + current_cycle + ".");
        ultrabreak = true;
        break;
      }

      // check 0 to loop again to make sure no atoms are sharing a position
      for(moreloop = 0; moreloop < loop; ++moreloop)
      {
        if(reactor_atoms[loop].next_position === reactor_atoms[moreloop].next_position)
        {
          text = (error_text + text);
          // console_write("Warning: reaction ends in an error: two atoms share position " + reactor_atoms[loop].next_position + " at the start of cycle " + (current_cycle + 1) + ".");
          warning_write("Reaction ends in an error: two atoms share position " + reactor_atoms[loop].next_position + " at the start of cycle " + (current_cycle + 1) + ".");
          ultrabreak = true;
          break;
        }
      }

      // checks passed, so update stuff
      reactor_atoms[loop].position = reactor_atoms[loop].next_position;
      // before resetting whatcha_doin, see if it was a rotate -- if it was, we
      // need to rotate some bonds;
      if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
      {
        useful_thing = reactor_atoms[loop].bond_up;
        reactor_atoms[loop].bond_up = reactor_atoms[loop].bond_left;
        reactor_atoms[loop].bond_left = reactor_atoms[loop].bond_down;
        reactor_atoms[loop].bond_down = reactor_atoms[loop].bond_right;
        reactor_atoms[loop].bond_right = useful_thing;
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCK)
      {
        useful_thing = reactor_atoms[loop].bond_up;
        reactor_atoms[loop].bond_up = reactor_atoms[loop].bond_right;
        reactor_atoms[loop].bond_right = reactor_atoms[loop].bond_down;
        reactor_atoms[loop].bond_down = reactor_atoms[loop].bond_left;
        reactor_atoms[loop].bond_left = useful_thing;
      }
      reactor_atoms[loop].whatcha_doin = WD_UNKNOWN;
      // reactor_atoms[loop].departure_status = DS_UNKNOWN;  // set later
      reactor_atoms[loop].most_recent_cycle = (current_cycle + 1);
      reactor_atoms[loop].axis_position = 0;
    }
    // if(ultrabreak) break;  // move this down a few lines so that it draws the
    // previous cycle

    ++current_cycle;

    sfx_text = "";
    text += "\n#";
    if(current_cycle > 1) text += "else";
    text += "if (clock < " + current_cycle + ")\n";
    needs_an_end = true;

    if(ultrabreak) break;  // yeah, to here

    // waldo pre-loop to update current cycle
    for(waldo_loop = 0; waldo_loop < the_waldos.length; ++waldo_loop)
    {
      the_waldos[waldo_loop].current_cycle = current_cycle;
      // and make sure they're in-bounds while we're here
      if(!validate_grid(the_waldos[waldo_loop].position))
      {
        // console_write("Error: waldo out of bounds... probably my fault, sorry");
        error_write("waldo out of bounds... probably my fault, sorry");
        return;
      }

      // DS_NONE for held atoms and the rest of their respective molecules
      if(the_waldos[waldo_loop].hold_atom)
      {
        // make sure it really has an atom
        if(find_atom_index(the_waldos[waldo_loop].position, false) < 0)
        {
          // console_write("Error: thought it did, but it didn\'t");
          error_write("thought it did, but it didn\'t");
          return;
        }
        if(!propagate(the_waldos[waldo_loop].position, current_cycle, DS_NONE, 0))
        {
          // console_write("Error: propagation failure");
          error_write("propagation failure");
          return;
        }
      }
    }

    // waldo loop
    for(waldo_loop = 0; waldo_loop < the_waldos.length; ++waldo_loop)
    {
      if(waldo_loop === 0) color_this_time = RED_STR;
      else if(waldo_loop === 1) color_this_time = BLUE_STR;
      else
      {
        // console_write("Error: pretty sure there are only two waldo colors");
        error_write("pretty sure there are only two waldo colors");
        return;
      }

      // set atoms' departure statuses
      for(loop = 0; loop < reactor_atoms.length; ++loop)
      {
        if((reactor_atoms[loop].departure_status != DS_DEPARTCONFIRM) &&
          (reactor_atoms[loop].departure_status != DS_NONE))
        {
          reactor_atoms[loop].departure_status = DS_UNKNOWN;
        }
      }

      // check for a directional control
      useful_thing = what_stuff_is_at_place(color_this_time,
        the_waldos[waldo_loop].position, true);
      if(useful_thing.length > 0)
      {
        if(!validate_direction(useful_thing))
        {
          // console_write("Error: aw heck!");
          error_write("aw heck!");
          return;
        }
        the_waldos[waldo_loop].direction = useful_thing;
      }

      the_waldos[waldo_loop].proceed = true;  // unless changed later

      // wall check
      if(!validate_grid(move_far(the_waldos[waldo_loop].position, 1,
        the_waldos[waldo_loop].direction)))
      {
        // pushing against a wall
        the_waldos[waldo_loop].proceed = false;
      }

      // instructions!
      useful_thing = get_thing_index(the_waldos[waldo_loop].position,
        color_this_time, false);
      if(useful_thing >= 0)
      {
        if(reactor_things_array[useful_thing].object_type === START_STR)
        {
          // ignore -- start direction was imparted during initialization
          continue;
        }
        else if((reactor_things_array[useful_thing].object_type === BOND_PLUS_STR) ||
          (reactor_things_array[useful_thing].object_type === BOND_MINUS_STR))
        {
          // no sense taking the easy ones first... not that there are any
          // easy ones

          // SPECIAL EFFECT: bonder flash
          if(bonder_spots.length > 0)
          {
            sfx_text += "union\n{\n";
            for(loop = 0; loop < bonder_spots.length; ++loop)
            {
              sfx_text += "  object {";
              if(color_this_time === RED_STR) sfx_text += "red";
              else sfx_text += "blue";
              sfx_text += "_bonder_flash translate ";
              sfx_text += origin_to_position_translates[bonder_spots[loop]];
              sfx_text += "}\n";
              // check to that bonder's right for another bonder
              one_spot = bonder_spots.indexOf(move_right(bonder_spots[loop]));
              if(one_spot >= 0)
              {
                // yep
                sfx_text += "  object {";
                if(color_this_time === RED_STR) sfx_text += "red";
                else sfx_text += "blue";
                sfx_text += "_bonder_join_flash translate ";
                sfx_text += origin_to_position_translates[bonder_spots[loop]];
                sfx_text += "}\n";
              }
              // now check down
              one_spot = bonder_spots.indexOf(move_down(bonder_spots[loop]));
              if(one_spot >= 0)
              {
                sfx_text += "  object {";
                if(color_this_time === RED_STR) sfx_text += "red";
                else sfx_text += "blue";
                sfx_text += "_bonder_join_flash rotate -90 * z translate ";
                sfx_text += origin_to_position_translates[bonder_spots[loop]];
                sfx_text += "}\n";
              }
            }
            sfx_text += "  no_shadow\n}\n";
          }

          for(loop = 0; loop < bonder_spots.length; ++loop)
          {
            one_spot = bonder_spots[loop];
            // start by seeing if there's an atom on this bonder
            one_atom = find_atom_index(one_spot, false);
            if(one_atom < 0) continue;
            // don't bond a DS_DEPARTCONFIRM
            if(reactor_atoms[one_atom].departure_status === DS_DEPARTCONFIRM)
            {
              continue;
            }

            // make sure it can take the bond change
            if(reactor_things_array[useful_thing].object_type === BOND_PLUS_STR)
            {
              // bond plus -- make sure it's under max bonds
              if((reactor_atoms[one_atom].bond_left +
                reactor_atoms[one_atom].bond_right +
                reactor_atoms[one_atom].bond_up +
                reactor_atoms[one_atom].bond_down) >=
                max_bonds[reactor_atoms[one_atom].atomic_number])
              {
                // SPECIAL EFFECT: max bonds
                // well this one will be a bit of work... I can't directly
                // place a max bonds flash -- I need to make sure there's...
                // 1. another bonder to its right or below...
                // 2. an atom on that bonder
                // let's see if I can do that check with a single compunded
                // condition... start with right
                if((bonder_spots.indexOf(move_right(bonder_spots[loop])) >= 0) &&
                  (find_atom_index(move_right(bonder_spots[loop]), false) >= 0))
                {
                  // max bonds flash right
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_max_bonds translate <0.5, 0, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
                // and down
                if((bonder_spots.indexOf(move_down(bonder_spots[loop])) >= 0) &&
                  (find_atom_index(move_down(bonder_spots[loop]), false) >= 0))
                {
                  // max bonds flash down
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_max_bonds translate <0, -0.5, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
                continue;
              }
            }
            // there are other conditions to check, but they depend on bond
            // position so they'll be checked in the next part
            
            // from each bonder, look right and down for another
            // (and do it with a loop)
            for(moreloop = 0; moreloop < 2; ++moreloop)
            {
              if(moreloop === 0) other_spot = move_right(bonder_spots[loop]);
              else other_spot = move_down(bonder_spots[loop]);
              if(!validate_grid(other_spot)) continue;

              // see whether there's a bonder there
              if(bonder_spots.indexOf(other_spot) < 0) continue;

              // now see if there's an atom there
              other_atom = find_atom_index(other_spot, false);
              if(other_atom < 0) continue;

              // if the other atom has a DS_DEPARTCONFIRM, skip it
              if(reactor_atoms[other_atom].departure_status === DS_DEPARTCONFIRM)
              {
                continue;
              }

              // make sure the other atom is under max bonds
              if(reactor_things_array[useful_thing].object_type === BOND_PLUS_STR)
              {
                if((reactor_atoms[other_atom].bond_left +
                  reactor_atoms[other_atom].bond_right +
                  reactor_atoms[other_atom].bond_up +
                  reactor_atoms[other_atom].bond_down) >=
                  max_bonds[reactor_atoms[other_atom].atomic_number])
                {
                  // SPECIAL EFFECT: max bonds
                  // this one's easier
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_max_bonds translate ";
                  if(moreloop === 0) sfx_text += "<0.5, 0, 0>";
                  else sfx_text += "<0, -0.5, 0>";
                  sfx_text += " translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                  continue;
                }
              }
              if(moreloop === 0)
              {
                if(reactor_atoms[one_atom].bond_right !=
                  reactor_atoms[other_atom].bond_left)
                {
                  // console_write("Error: bond mismatch");
                  error_write("bond mismatch");
                  return;
                }
                if(reactor_things_array[useful_thing].object_type === BOND_PLUS_STR)
                {
                  // make sure this bond alignment is under 3
                  if(reactor_atoms[one_atom].bond_right > 2)
                  {
                    continue;
                    // (special effect note: Spacechem does a bond+ flash even
                    // if it's already a triple bond; it does not do a bond-
                    // flash when trying to remove where there is no bond)
                    // (further note: I may ignore this and do what I feel like)
                  }
                }
                else
                {
                  // make sure there's a bond to remove at this alignment
                  if(reactor_atoms[one_atom].bond_right < 1) continue;
                }
              }
              else
              {
                // moreloop is 1; same as for 0 but down
                if(reactor_atoms[one_atom].bond_down !=
                  reactor_atoms[other_atom].bond_up)
                {
                  // console_write("Error: bond mismatch");
                  error_write("bond mismatch");
                  return;
                }
                if(reactor_things_array[useful_thing].object_type === BOND_PLUS_STR)
                {
                  // make sure this bond alignment is under 3
                  if(reactor_atoms[one_atom].bond_down > 2)
                  {
                    continue;
                    // SPECIAL EFFECT... MAYBE: bond+ flash
                  }
                }
                else
                {
                  // make sure there's a bond to remove at this alignment
                  if(reactor_atoms[one_atom].bond_down < 1) continue;
                }
              }

              // all right -- two atoms on two adjacent bonders ready to
              // bond or de-bond
              if(reactor_things_array[useful_thing].object_type === BOND_PLUS_STR)
              {
                if(moreloop === 0)
                {
                  // bond right
                  ++(reactor_atoms[one_atom].bond_right);
                  ++(reactor_atoms[other_atom].bond_left);
                  // SPECIAL EFFECT: Bond+ flash
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_bond_plus_flash translate <0.5, 0, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
                else
                {
                  // bond down
                  ++(reactor_atoms[one_atom].bond_down);
                  ++(reactor_atoms[other_atom].bond_up);
                  // SPECIAL EFFECT: Bond+ flash
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_bond_plus_flash translate <0, -0.5, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
              }
              else
              {
                if(moreloop === 0)
                {
                  // de-bond right
                  --(reactor_atoms[one_atom].bond_right);
                  --(reactor_atoms[other_atom].bond_left);
                  // SPECIAL EFFECT: Bond- flash
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_bond_minus_flash translate <0.5, 0, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
                else
                {
                  // de-bond down
                  --(reactor_atoms[one_atom].bond_down);
                  --(reactor_atoms[other_atom].bond_up);
                  // SPECIAL EFFECT: Bond- flash
                  sfx_text += "object {";
                  if(color_this_time === RED_STR) sfx_text += "red";
                  else sfx_text += "blue";
                  sfx_text += "_bond_minus_flash translate <0, -0.5, 0> translate ";
                  sfx_text += origin_to_position_translates[bonder_spots[loop]];
                  sfx_text += "}\n";
                }
              }
            }  // end of moreloop (directions)
          }  // end of bonder spots loop
        }  // end of if it's a bond+ or bond-
        else if(reactor_things_array[useful_thing].object_type === GRABDROP_STR)
        {
          if(the_waldos[waldo_loop].hold_atom)
          {
            the_waldos[waldo_loop].hold_atom = false;
            if(!propagate(the_waldos[waldo_loop].position,
              current_cycle, DS_UNKNOWN, 0))
            {
              // console_write("Error: propagation problem");
              error_write("propagation problem");
              return;
            }
          }
          else
          {
            more_useful = find_atom_index(the_waldos[waldo_loop].position,false);
            if(more_useful >= 0)
            {
              // don't grab a DS_DEPARTCONFIRM
              if(reactor_atoms[more_useful].departure_status != DS_DEPARTCONFIRM)
              {
                the_waldos[waldo_loop].hold_atom = true;
                if(!propagate(the_waldos[waldo_loop].position,
                  current_cycle, DS_NONE, 0))
                {
                  // console_write("Error: one of many possible propagation problems");
                  error_write("one of many possible propagation problems");
                  return;
                }
              }
            }
          }
        }
        else if(reactor_things_array[useful_thing].object_type === GRAB_STR)
        {
          if(!the_waldos[waldo_loop].hold_atom)
          {
            more_useful = find_atom_index(the_waldos[waldo_loop].position, false);
            if(more_useful >= 0)
            {
              // don't pick up a DS_DEPARTCONFIRM
              if(reactor_atoms[more_useful].departure_status != DS_DEPARTCONFIRM)
              {
                the_waldos[waldo_loop].hold_atom = true;
                if(!propagate(the_waldos[waldo_loop].position,
                  current_cycle, DS_NONE, 0))
                {
                  // console_write("Error: propagation gone wrong");
                  error_write("propagation gone wrong");
                  return;
                }
              }
            }
          }
        }
        else if(reactor_things_array[useful_thing].object_type === DROP_STR)
        {
          if(the_waldos[waldo_loop].hold_atom)
          {
            more_useful = find_atom_index(the_waldos[waldo_loop].position, false);
            if(more_useful < 0)
            {
              // console_write("Error: Amazing!  Where did it go?");
              error_write("Amazing!  Where did it go?");
              return;
            }
            the_waldos[waldo_loop].hold_atom = false;
            if(!propagate(the_waldos[waldo_loop].position,
              current_cycle, DS_UNKNOWN, 0))
            {
              // console_write("Error: propagation heck-up");
              error_write("propagation heck-up");
              return;
            }
          }
        }
        else if((reactor_things_array[useful_thing].object_type === IN_BETA_STR) ||
          (reactor_things_array[useful_thing].object_type === IN_ALPHA_STR))
        {
          // if this is the blue waldo, see if the red waldo is also on the
          // same input instruction -- if it is, stall until it isn't (and then
          // hope that the next molecule does not overlap the current, otherwise
          // the reaction will end in an error
          if(color_this_time === BLUE_STR)
          {
            more_useful = get_thing_index(the_waldos[0].position,
              RED_STR, false);
            if(more_useful >= 0)
            {
              if(reactor_things_array[more_useful].object_type ===
                reactor_things_array[useful_thing].object_type)
              {
                // red waldo is on input instruction for same input -- stall
                the_waldos[1].proceed = false;
                continue;
              }
            }
          }

          // SPECIAL EFFECT: input pad flash
          sfx_text += "object {";
          if(color_this_time === RED_STR) sfx_text += "red";
          else sfx_text += "blue";
          if(reactor_things_array[useful_thing].object_type === IN_ALPHA_STR)
          {
            sfx_text += "_alpha";
          }
          else
          {
            sfx_text += "_beta";
          }
          sfx_text += "_flash}\n";

          // initialize the correct input grid
          check_grid.length = 0;
          if(reactor_things_array[useful_thing].object_type === IN_ALPHA_STR)
          {
            for(loop = 0; loop < alpha_to_grid.length; ++loop)
            {
              check_grid.push(alpha_to_grid[loop]);
            }
          }
          else
          {
            for(loop = 0; loop < beta_to_grid.length; ++loop)
            {
              check_grid.push(beta_to_grid[loop]);
            }
          }

          // see what atoms are already in that area...
          claimed.length = 0;
          for(loop = 1; loop < check_grid.length; ++loop)
          {
            more_useful = find_atom_index(check_grid[loop], false);
            if(more_useful >= 0)
            {
              if(claimed.indexOf(check_grid[loop]) >= 0)
              {
                // console_write("Error: an atom collision I should have caught earlier");
                error_write("an atom collision I should have caught earlier");
                return;
              }
              claimed.push(check_grid[loop]);
            }
          }

          // now initialize the array for the new molecule
          if(reactor_things_array[useful_thing].object_type === IN_ALPHA_STR)
          {
            if((!at_least_one_alpha) || (alpha_sequence_array.length === 0))
            {
              // oh dear!  this waldo will be stuck forever waiting for a
              // molecule that will never arrive!
              the_waldos[waldo_loop].proceed = false;
              continue;
            }
            // now that we've established there is at least one molecule,
            // find it
            if(alpha_sequence_index >= alpha_sequence_array.length)
            {
              alpha_sequence_index = 0;
            }
            // skip over any empty molecules and fill insert_molecule with
            // the first non-empty
            still_looking = true;
            while(still_looking)
            {
              insert_molecule.length = 0;
              if(alpha_sequence_array[alpha_sequence_index] === "A1")
              {
                for(loop = 0; loop < molecule_a1.length; ++loop)
                {
                  insert_molecule.push(molecule_a1[loop].new_copy());
                }
              }
              else if(alpha_sequence_array[alpha_sequence_index] === "A2")
              {
                for(loop = 0; loop < molecule_a2.length; ++loop)
                {
                  insert_molecule.push(molecule_a2[loop].new_copy());
                }
              }
              else
              {
                for(loop = 0; loop < molecule_a3.length; ++loop)
                {
                  insert_molecule.push(molecule_a3[loop].new_copy());
                }
              }
              if(insert_molecule.length > 0)
              {
                // got one
                still_looking = false;
              }
              // and whether or not we got one, advance the index for next time
              ++alpha_sequence_index;
              if(alpha_sequence_index >= alpha_sequence_array.length)
              {
                alpha_sequence_index = 0;
              }
            }
          }  // end of if it's alpha
          else
          {
            // now I get to write all that again for beta
            if((!at_least_one_beta) || (beta_sequence_array.length === 0))
            {
              // oh dear!  this waldo will be stuck forever waiting for a
              // molecule that will never arrive!
              the_waldos[waldo_loop].proceed = false;
              continue;
            }
            // now that we've established there is at least one molecule,
            // find it
            if(beta_sequence_index >= beta_sequence_array.length)
            {
              beta_sequence_index = 0;
            }
            // skip over any empty molecules and fill insert_molecule with
            // the first non-empty
            still_looking = true;
            while(still_looking)
            {
              insert_molecule.length = 0;
              if(beta_sequence_array[beta_sequence_index] === "B1")
              {
                for(loop = 0; loop < molecule_b1.length; ++loop)
                {
                  insert_molecule.push(molecule_b1[loop].new_copy());
                }
              }
              else if(beta_sequence_array[beta_sequence_index] === "B2")
              {
                for(loop = 0; loop < molecule_b2.length; ++loop)
                {
                  insert_molecule.push(molecule_b2[loop].new_copy());
                }
              }
              else
              {
                for(loop = 0; loop < molecule_b3.length; ++loop)
                {
                  insert_molecule.push(molecule_b3[loop].new_copy());
                }
              }
              if(insert_molecule.length > 0)
              {
                // got one
                still_looking = false;
              }
              // found or not, advance the index for next time
              ++beta_sequence_index;
              if(beta_sequence_index >= beta_sequence_array.length)
              {
                beta_sequence_index = 0;
              }
            }
          }  // end of if it's beta

          // so now we have an array for the incoming molecule, a translation
          // grid to tell it where to go, and a grid marking where atoms
          // already are.  Start adding those atoms to the reactor, and if
          // any of them overlap with any others, end the reaction in an error
          for(loop = 0; loop < insert_molecule.length; ++loop)
          {
            if(!validate_grid(insert_molecule[loop].position))
            {
              // it's not on that grid, yet, but any valid position for an
              // input atom will be a valid grid position, too, and that does
              // all but one needed check
              // console_write("Error: bad atom position");
              error_write("bad atom position");
              return;
            }
            if(insert_molecule[loop].position >= check_grid.length)
            {
              // console_write("Error: bad atom position");
              error_write("bad atom position");
              return;
            }
            more_useful = check_grid[insert_molecule[loop].position];
            if(claimed.indexOf(more_useful) >= 0)
            {
              // reaction error -- atom collision
              error_text = "// WARNING: This reaction ends in an error.\n";
              error_text += "// See the output log at the top of the PovChem page for details.\n\n";
              text = (error_text + text);
              // error_text = "Warning: reaction ends in the following error: ";
              error_text = "Reaction ends in the following error: ";
              error_text += "atom collision on input at position " + more_useful;
              error_text += " on cycle " + current_cycle;
              // console_write(error_text);
              warning_write(error_text);
              ultrabreak = true;
              break;
            }
            claimed.push(more_useful);

            // the insert!
            reactor_atoms.push(insert_molecule[loop].new_copy());
            reactor_atoms[reactor_atoms.length - 1].position = more_useful;
            reactor_atoms[reactor_atoms.length - 1].next_position = more_useful;
            reactor_atoms[reactor_atoms.length - 1].most_recent_cycle = current_cycle;
            reactor_atoms[reactor_atoms.length - 1].whatcha_doin = WD_UNKNOWN;
            reactor_atoms[reactor_atoms.length - 1].departure_status = DS_UNKNOWN;
          }
          if(ultrabreak) break;

          // if all went well there should be a new molecule in the reactor

        }  // end of if it's In Alpha or In Beta
        else if((reactor_things_array[useful_thing].object_type === OUT_PSI_STR) ||
          (reactor_things_array[useful_thing].object_type === OUT_OMEGA_STR))
        {
          if(use_big_psi &&
            (reactor_things_array[useful_thing].object_type === OUT_OMEGA_STR))
          {
            // well that case was easy
            continue;
          }

          // SPECIAL EFFECT: output pad flash
          sfx_text += "object {";
          if(color_this_time === RED_STR) sfx_text += "red";
          else sfx_text += "blue";
          if(use_big_psi)
          {
            sfx_text += "_big_psi";
          }
          else
          {
            if(reactor_things_array[useful_thing].object_type === OUT_PSI_STR)
            {
              sfx_text += "_psi";
            }
            else
            {
              sfx_text += "_omega";
            }
          }
          sfx_text += "_flash}\n";

          // decide which output region to check
          check_grid.length = 0;
          if(use_big_psi)  // and we've already established it can't be omega
          {
            for(loop = 0; loop < big_psi_region.length; ++loop)
            {
              check_grid.push(big_psi_region[loop]);
            }
          }
          else if(reactor_things_array[useful_thing].object_type === OUT_PSI_STR)
          {
            for(loop = 0; loop < psi_region.length; ++loop)
            {
              check_grid.push(psi_region[loop]);
            }
          }
          else
          {
            for(loop = 0; loop < omega_region.length; ++loop)
            {
              check_grid.push(omega_region[loop]);
            }
          }

          // see if any atoms are in that region
          check_progress = DS_UNKNOWN;
          // actually, first, if this is the blue waldo, see whether the red
          // waldo already assigned a DEPARTCONFIRM for some molecule in here
          if(color_this_time === BLUE_STR)
          {
            for(loop = 0; loop < reactor_atoms.length; ++loop)
            {
              if(reactor_atoms[loop].departure_status === DS_DEPARTCONFIRM)
              {
                // a DEPARTCONFIRM will either be entirely inside this pad or
                // entirely outside it, inside the other pad -- so we only need
                // to check this one atom
                if(check_grid.indexOf(reactor_atoms[loop].position) >= 0)
                {
                  // same pad
                  check_progress = DS_DEPARTCONFIRM;
                }
                break;
              }
            }
          }
          // now see if there are any atoms in there
          for(loop = 0; loop < check_grid.length; ++loop)
          {
            more_useful = find_atom_index(check_grid[loop], false);
            if(more_useful >= 0)
            {
              // found an atom! now, what to do with it?
              // if we've already assigned a DEPARTCONFIRM, we still need to
              // check for other molecules that would be eligible for departure
              // if not for the one that already got it -- if there are any more
              // such molecules, the waldo needs to stall until it can send them
              // all
              // okay, so -- once an atom is found in this region, propagate
              // a DS_DEPARTCHECK.  Then look through reactor_atoms to see which
              // atoms got that status.  If any are outside the pad, propagate
              // a DS_DEPARTFAIL back through the molecule.  If it's all inside,
              // then...
              // - If we haven't already set check_progress to DS_DEPARTCONFIRM,
              //   propagate DS_DEPARTCONFIRM through that molecule and set
              //   check_progress to DS_DEPARTCONFIRM.
              // - If we have already set that, propagate DS_DEPARTBLOCK through
              //   that molecule and stall the waldo.
              if(reactor_atoms[more_useful].departure_status != DS_UNKNOWN)
              {
                // this one has already been assigned some status
                continue;
              }
              if(!propagate(check_grid[loop], current_cycle, DS_DEPARTCHECK, 0))
              {
                // console_write("Error: propagation problem");
                error_write("propagation problem");
                return;
              }
              // we can borrow still_looking to be our success flag
              still_looking = true;
              // if we assign a DS_DEPARTFAIL, set it false
              for(moreloop = 0; moreloop < reactor_atoms.length; ++moreloop)
              {
                if(reactor_atoms[moreloop].departure_status === DS_DEPARTCHECK)
                {
                  if(check_grid.indexOf(reactor_atoms[moreloop].position) < 0)
                  {
                    // depart fail
                    if(!propagate(reactor_atoms[moreloop].position,
                      current_cycle, DS_DEPARTFAIL, 0))
                    {
                      // console_write("Error: propagation problem");
                      error_write("propagation problem");
                      return;
                    }
                    still_looking = false;
                    break;
                  }
                }
              }
              // see how we did
              if(still_looking)
              {
                // eligible for departure... but on this cycle?
                if(check_progress === DS_DEPARTCONFIRM)
                {
                  // nope... better stall the waldo
                  if(!propagate(check_grid[loop], current_cycle,
                    DS_DEPARTBLOCK, 0))
                  {
                    // console_write("Error: propagation lamentation");
                    error_write("propagation lamentation");
                    return;
                  }
                  the_waldos[waldo_loop].proceed = false;
                }
                else
                {
                  // then off it goes!... or at least postmark it
                  if(!propagate(check_grid[loop], current_cycle,
                    DS_DEPARTCONFIRM, 0))
                  {
                    // console_write("Error: propagation frustration");
                    error_write("propagation frustration");
                    return;
                  }
                  check_progress = DS_DEPARTCONFIRM;
                  // and tally up one for whichever output this is
                  if(reactor_things_array[useful_thing].object_type === OUT_PSI_STR)
                  {
                    ++psi_count;
                  }
                  else
                  {
                    ++omega_count;
                  }
                }
              }
            }
          }
        }
        else if(reactor_things_array[useful_thing].object_type === SYNC_STR)
        {
          // peek at the other waldo to see if it's also on a sync
          if(waldo_loop === 0)
          {
            more_useful = get_thing_index(the_waldos[1].position,
              BLUE_STR, false);
          }
          else
          {
            more_useful = get_thing_index(the_waldos[0].position,
              RED_STR, false);
          }
          if(more_useful >= 0)
          {
            // other waldo is on a thing, but what kind?
            if(reactor_things_array[more_useful].object_type != SYNC_STR)
            {
              // it's not a sync -- better wait
              the_waldos[waldo_loop].proceed = false;
            }
            // else is implied -- proceed has already been set in other checks
            // so if it is a sync, let that setting stand
          }
          else
          {
            // other waldo is not on a thing, so it certainly isn't on a sync
            the_waldos[waldo_loop].proceed = false;
          }
        }
        else if((reactor_things_array[useful_thing].object_type === ROT_CLOCK_STR) ||
          (reactor_things_array[useful_thing].object_type === ROT_CCLOCK_STR))
        {
          // first and easiest, is this waldo holding anything?
          if(!the_waldos[waldo_loop].hold_atom)
          {
            // nope, seeya next time
            // but... just in case what it was holding was snagged by a
            // tunnel or fusion target or some such...
            the_waldos[waldo_loop].last_cycle_was_rotate = false;
            continue;
          }
          // okay, it is, but did it just already do this?  Let's answer that
          // by seeing if the waldo is on the same spot it was last time
          // (this may create an edge-case difference between Povchem and
          // Spacechem -- in Spacechem, if a waldo is pushing into a wall and
          // is on a rotate instruction, it will alternate rotating / not
          // rotating each cycle, whereas a Povchem waldo in a smilar situation
          // will rotate once and then no more.  However, if the held molecule
          // is only one atom then there is no practical difference, and if it
          // is more than one atom then the Spacechem reaction has a maximum
          // of two safe rotations before the reaction crashes on the third...
          // UNLESS THERE'S SOMETHING LIKE A FUSION TARGET OR QUANTUM TUNNEL
          // THERE... great, I just realized I do have to account for this case,
          // because devices like those could rescue an atom about to be rotated
          // off the grid.  Come to think of it, so could simply de-bonding the
          // rest of the molecule from the axis atom.  I went entirely the wrong
          // direction when thinking this through.)
          // So, instead of that check, I'll add a bool to the waldo declaration
          // called last_cycle_was_rotate.  It'll be false by default and will
          // only be set true and back to false back here.  This will bring
          // its behavior back in line with Spacechem in this regard.
          if(the_waldos[waldo_loop].last_cycle_was_rotate)
          {
            // off it goes
            the_waldos[waldo_loop].last_cycle_was_rotate = false;
            continue;
          }
          // wasn't a rotate, then -- so better do it this time
          // propagate the preliminary rotate status and the axis
          if(reactor_things_array[useful_thing].object_type === ROT_CLOCK_STR)
          {
            more_useful = WD_ROTCLOCKPRELIM;
          }
          else
          {
            more_useful = WD_ROTCOUNTERCLOCKPRELIM;
          }
          the_waldos[waldo_loop].last_cycle_was_rotate = true;
          the_waldos[waldo_loop].proceed = false;
          if(!propagate(the_waldos[waldo_loop].position,
            current_cycle, more_useful, the_waldos[waldo_loop].position))
          {
            // console_write("Error: propagation lack of imagination");
            error_write("propagation lack of imagination");
            return;
          }
        }
        else if(reactor_things_array[useful_thing].object_type === SENS_REDIR_STR)
        {
          if(reactor_things_array[useful_thing].state != 0)
          {
            the_waldos[waldo_loop].direction = reactor_things_array[useful_thing].direction;
          }

          // SPECIAL EFFECT: sensor flash
          if(validate_grid(sensor_spot))
          {
            sfx_text += "object {";
            if(color_this_time === RED_STR) sfx_text += "red";
            else sfx_text += "blue";
            sfx_text += "_sensor_flash translate ";
            sfx_text += origin_to_position_translates[sensor_spot];
            sfx_text += "}\n";
          }
        }
        else if(reactor_things_array[useful_thing].object_type === FUSE_STR)
        {
          if(!(validate_grid(fuse_left) && validate_grid(fuse_right)))
          {
            continue;
          }
          // I'll count on some previous error checking having been done right
          one_atom = find_atom_index(fuse_left, false);
          if(one_atom < 0) continue;
          other_atom = find_atom_index(fuse_right, false);
          if(other_atom < 0) continue;
          if((reactor_atoms[one_atom].atomic_number +
            reactor_atoms[other_atom].atomic_number) > 109) continue;
          // atoms can fuse
          // fuse can change molecules, so propagate DS_UNKNOWN to any held
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            if(the_waldos[loop].hold_atom)
            {
              if(!propagate(the_waldos[loop].position, current_cycle,
                DS_UNKNOWN, 0))
              {
                // console_write("Error: propagation problem");
                error_write("propagation problem");
                return;
              }
            }
          }
          // remove projectile atom
          if(reactor_atoms[one_atom].bond_left > 0)
          {
            more_useful = find_atom_index(move_left(fuse_left), false);
            if(more_useful < 0)
            {
              // console_write("Error: oh no!");
              error_write("oh no!");
              return;
            }
            reactor_atoms[more_useful].bond_right = 0;
          }
          if(reactor_atoms[one_atom].bond_right > 0)
          {
            more_useful = find_atom_index(move_right(fuse_left), false);
            if(more_useful < 0)
            {
              // console_write("Error: oh gosh!");
              error_write("oh gosh!");
              return;
            }
            reactor_atoms[more_useful].bond_left = 0;
          }
          if(reactor_atoms[one_atom].bond_up > 0)
          {
            more_useful = find_atom_index(move_up(fuse_left), false);
            if(more_useful < 0)
            {
              // console_write("Error: oh golly!");
              error_write("oh golly!");
              return;
            }
            reactor_atoms[more_useful].bond_down = 0;
          }
          if(reactor_atoms[one_atom].bond_down > 0)
          {
            more_useful = find_atom_index(move_down(fuse_left), false);
            if(more_useful < 0)
            {
              // console_write("Error: well heck");
              error_write("well heck");
              return;
            }
            reactor_atoms[more_useful].bond_up = 0;
          }
          // hmm, better increase the target's atomic number and take care of
          // its bonds before we splice out the projectile and possibly throw
          // an index off
          reactor_atoms[other_atom].atomic_number += reactor_atoms[one_atom].atomic_number;
          while((reactor_atoms[other_atom].bond_up +
            reactor_atoms[other_atom].bond_right +
            reactor_atoms[other_atom].bond_down) >
            max_bonds[reactor_atoms[other_atom].atomic_number])
          {
            // no need to check bond_left -- that's where the projectile was
            // let's see... one_spot and other_spot are available as spares
            // one_spot will be the index (top, right, down) and other_spot
            // will be the bond strength at that orientation.  Remove bonds
            // so as to work toward a roughly even bond distribution.

            // That turns out to be mostly how the game itself does things, but
            // it apparently removes in the order side, top, bottom once bonds
            // are even strength; rather than top, side, bottom as I did.  Time
            // to make those match.  So one_spot will still index top, right,
            // down, respectively, but those bonds will be checked in a new
            // order.
            // one_spot = 0;
            // other_spot = reactor_atoms[other_atom].bond_up;
            one_spot = 1;
            other_spot = reactor_atoms[other_atom].bond_right;
            // if(reactor_atoms[other_atom].bond_right > other_spot)
            if(reactor_atoms[other_atom].bond_up > other_spot)
            {
              // one_spot = 1;
              // other_spot = reactor_atoms[other_atom].bond_right;
              one_spot = 0;
              other_spot = reactor_atoms[other_atom].bond_up;
            }
            if(reactor_atoms[other_atom].bond_down > other_spot)
            {
              one_spot = 2;
              other_spot = reactor_atoms[other_atom].bond_down;
            }
            if(other_spot <= 0)
            {
              // console_write("Error: atomic brittleness");
              error_write("atomic brittleness");
              return;
            }
            if(one_spot === 0)
            {
              --(reactor_atoms[other_atom].bond_up);
              more_useful = find_atom_index(move_up(fuse_right), false);
              if(more_useful < 0)
              {
                // console_write("Error: whoops");
                error_write("whoops");
                return;
              }
              if(reactor_atoms[more_useful].bond_down <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_down);
            }
            else if(one_spot === 1)
            {
              --(reactor_atoms[other_atom].bond_right);
              more_useful = find_atom_index(move_right(fuse_right), false);
              if(more_useful < 0)
              {
                // console_write("Error: darn");
                error_write("darn");
                return;
              }
              if(reactor_atoms[more_useful].bond_left <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_left);
            }
            else
            {
              --(reactor_atoms[other_atom].bond_down);
              more_useful = find_atom_index(move_down(fuse_right), false);
              if(more_useful < 0)
              {
                // console_write("Error: shoot");
                error_write("shoot");
                return;
              }
              if(reactor_atoms[more_useful].bond_up <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_up);
            }
          }
          // now splice out the projectile atom
          reactor_atoms.splice(one_atom, 1);
          // and propagate DS_NONE back to held molecules
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            // if it wasn't holding anything before, that hasn't changed
            if(the_waldos[loop].hold_atom)
            {
              // if it was, see whether it still is
              one_atom = find_atom_index(the_waldos[loop].position, false);
              if(one_atom < 0)
              {
                // it isn't... must have gotten fused away
                the_waldos[loop].hold_atom = false;
              }
              else
              {
                // still is -- propagate DS_NONE
                if(!propagate(the_waldos[loop].position, current_cycle,
                  DS_NONE, 0))
                {
                  // console_write("Error: propagation nah");
                  error_write("propagation nah");
                  return;
                }
              }
            }
          }

          // SPECIAL EFFECT: fusion laser and fusion target flash
          sfx_text += "object {";
          if(color_this_time === RED_STR) sfx_text += "red";
          else sfx_text += "blue";
          sfx_text += "_fusion_flash translate ";
          sfx_text += origin_to_position_translates[fuse_right];
          sfx_text += "}\n";
        }
        else if(reactor_things_array[useful_thing].object_type === SPLIT_STR)
        {
          if(!(validate_grid(fiss_left) && validate_grid(fiss_right)))
          {
            // no fission target
            continue;
          }
          one_atom = find_atom_index(fiss_left, false);
          if(one_atom < 0)
          {
            // target empty
            continue;
          }
          if(reactor_atoms[one_atom].atomic_number > 109)
          {
            // can't split atoms of special elements
            continue;
            // well... turns out you can
          }
          if(reactor_atoms[one_atom].atomic_number === 1)
          {
            // can't split hydrogen
            continue;
          }
          // atom can be split
          other_atom = find_atom_index(fiss_right, false);
          if(other_atom >= 0)
          {
            // reaction error -- atom collision
            error_text = "// WARNING: This reaction ends in an error.\n";
            error_text += "// See the output log at the top of the PovChem page for details.\n\n";
            text = (error_text + text);
            // error_text = "Warning: reaction ends in an error: ";
            error_text = "Reaction ends in an error: ";
            error_text += "atom collision at position " + fiss_right;
            error_text += " on cycle " + current_cycle;
            error_text += " as the result of an atomic fission";
            // console_write(error_text);
            warning_write(error_text);
            ultrabreak = true;
            break;
          }
          // other part of target not occupied; we're gonna split this
          // and because a molecule can change if the remaining atom supports
          // fewer max. bonds, propagate a DS_UNKNOWN to held molecules...
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            if(the_waldos[loop].hold_atom)
            {
              if(!propagate(the_waldos[loop].position, current_cycle,
                DS_UNKNOWN, 0))
              {
                // console_write("Error: propagation meh");
                error_write("propagation meh");
                return;
              }
            }
          }
          fiss_newguy = new atom();
          fiss_newguy.atomic_number = Math.floor(
            (reactor_atoms[one_atom].atomic_number) / 2);
          fiss_newguy.position = fiss_right;
          fiss_newguy.most_recent_cycle = current_cycle;
          fiss_newguy.whatcha_doin = WD_UNKNOWN;
          fiss_newguy.departure_status = DS_UNKNOWN;
          fiss_newguy.next_position = fiss_right;
          // before we add the new atom, adjust the old one
          reactor_atoms[one_atom].atomic_number -= fiss_newguy.atomic_number;
          // and make sure it's bonds don't exceed the new maximum
          // this will be very similar to how I did it for the fusion section
          while((reactor_atoms[one_atom].bond_up +
            reactor_atoms[one_atom].bond_left +
            reactor_atoms[one_atom].bond_down) >
            max_bonds[reactor_atoms[one_atom].atomic_number])
          {
            // this time the index is top, left, down, and right is ignored
            // because if it were anything other than zero, the reaction
            // would have already hit an error

            // And I'm modifying the order in which they are checked here to
            // side, top, bottom, too.

            // one_spot = 0;
            // other_spot = reactor_atoms[one_atom].bond_up;
            one_spot = 1;
            other_spot = reactor_atoms[one_atom].bond_left;
            // if(reactor_atoms[one_atom].bond_left > other_spot)
            if(reactor_atoms[one_atom].bond_up > other_spot)
            {
              // one_spot = 1;
              // other_spot = reactor_atoms[one_atom].bond_left;
              one_spot = 0;
              other_spot = reactor_atoms[one_atom].bond_up;
            }
            if(reactor_atoms[one_atom].bond_down > other_spot)
            {
              one_spot = 2;
              other_spot = reactor_atoms[one_spot].bond_down;
            }
            if(other_spot <= 0)
            {
              // console_write("Error: atom fallibility");
              error_write("atom fallibility");
              return;
            }
            if(one_spot === 0)
            {
              --(reactor_atoms[one_atom].bond_up);
              more_useful = find_atom_index(move_up(fiss_left), false);
              if(more_useful < 0)
              {
                // console_write("Error: it didn\'t work");
                error_write("it didn\'t work");
                return;
              }
              if(reactor_atoms[more_useful].bond_down <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_down);
            }
            else if(one_spot === 1)
            {
              --(reactor_atoms[one_atom].bond_left);
              more_useful = find_atom_index(move_left(fiss_left), false);
              if(more_useful < 0)
              {
                // console_write("Error: no good hats left");
                error_write("no good hats left");
                return;
              }
              if(reactor_atoms[more_useful].bond_right <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_right);
            }
            else
            {
              --(reactor_atoms[one_atom].bond_down);
              more_useful = find_atom_index(move_down(fiss_left), false);
              if(more_useful < 0)
              {
                // console_write("Error: missing an atom");
                error_write("missing an atom");
                return;
              }
              if(reactor_atoms[more_useful].bond_up <= 0)
              {
                // console_write("Error: bond miscount");
                error_write("bond miscount");
                return;
              }
              --(reactor_atoms[more_useful].bond_up);
            }
          }
          // there we go
          reactor_atoms.push(fiss_newguy);
          // now propagate DS_NONE back to any held molecules
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            if(the_waldos[loop].hold_atom)
            {
              // no question of releasing an atom this time -- fission doesn't
              // remove anything
              if(!propagate(the_waldos[loop].position, current_cycle,
                DS_NONE, 0))
              {
                // console_write("Error: propagation discombobulation");
                error_write("propagation discombobulation");
                return;
              }
            }
          }

          // SPECIAL EFFECT: fission laser and target flash
          sfx_text += "object {";
          if(color_this_time == RED_STR) sfx_text += "red";
          else sfx_text += "blue";
          sfx_text += "_fission_flash translate ";
          sfx_text += origin_to_position_translates[fiss_left];
          sfx_text += "}\n";
        }
        else if(reactor_things_array[useful_thing].object_type === FLIP_FLOP_STR)
        {
          if(reactor_things_array[useful_thing].state === 0)
          {
            reactor_things_array[useful_thing].state = 1;
          }
          else
          {
            the_waldos[waldo_loop].direction =
              reactor_things_array[useful_thing].direction;
            reactor_things_array[useful_thing].state = 0;
          }
        }
        else if(reactor_things_array[useful_thing].object_type === SWAP_STR)
        {
          swap_beam = false;
          flash_tunnel_one = false;
          flash_tunnel_other = false;
          if(!(validate_grid(tunnel_one) && validate_grid(tunnel_other)))
          {
            // no tunnel
            continue;
          }
          // propagate DS_UNKNOWN to held molecules in case a key part gets sent
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            if(the_waldos[loop].hold_atom)
            {
              if(!propagate(the_waldos[loop].position, current_cycle,
                DS_UNKNOWN, 0))
              {
                // console_write("Error: propagation deforestation");
                error_write("propagation deforestation");
                return;
              }
            }
          }
          // I don't feel like writing this twice, so...
          for(loop = 0; loop < 2; ++loop)
          {
            if(loop === 0)
            {
              one_spot = tunnel_one;
            }
            else
            {
              one_spot = tunnel_other;
            }
            // if there's an atom here, remove its bonds but don't swap it yet
            // or one that gets found on the first iteration would get swapped
            // back on the second
            one_atom = find_atom_index(one_spot, false);
            if(one_atom >= 0)
            {
              swap_beam = true;
              if(loop === 0)
              {
                flash_tunnel_other = true;
              }
              else
              {
                flash_tunnel_one = true;
              }
              if(reactor_atoms[one_atom].bond_up > 0)
              {
                other_atom = find_atom_index(move_up(one_spot), false);
                if(other_atom < 0)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                if(reactor_atoms[other_atom].bond_down != reactor_atoms[one_atom].bond_up)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                reactor_atoms[one_atom].bond_up = 0;
                reactor_atoms[other_atom].bond_down = 0;
              }
              if(reactor_atoms[one_atom].bond_down > 0)
              {
                other_atom = find_atom_index(move_down(one_spot), false);
                if(other_atom < 0)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                if(reactor_atoms[other_atom].bond_up != reactor_atoms[one_atom].bond_down)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                reactor_atoms[one_atom].bond_down = 0;
                reactor_atoms[other_atom].bond_up = 0;
              }
              if(reactor_atoms[one_atom].bond_left > 0)
              {
                other_atom = find_atom_index(move_left(one_spot), false);
                if(other_atom < 0)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                if(reactor_atoms[other_atom].bond_right != reactor_atoms[one_atom].bond_left)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                reactor_atoms[one_atom].bond_left = 0;
                reactor_atoms[other_atom].bond_right = 0;
              }
              if(reactor_atoms[one_atom].bond_right > 0)
              {
                other_atom = find_atom_index(move_right(one_spot), false);
                if(other_atom < 0)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                if(reactor_atoms[other_atom].bond_left != reactor_atoms[one_atom].bond_right)
                {
                  // console_write("Error: bond problem");
                  error_write("bond problem");
                  return;
                }
                reactor_atoms[one_atom].bond_right = 0;
                reactor_atoms[other_atom].bond_left = 0;
              }
            }
          }
          // now look at the tunnel ends and swap whatever is found there...
          // and use that sepcial effects flag to see whether we need to
          if(swap_beam)
          {
            one_atom = find_atom_index(tunnel_one, false);
            other_atom = find_atom_index(tunnel_other, false);
            if(one_atom >= 0)
            {
              reactor_atoms[one_atom].position = tunnel_other;
            }
            if(other_atom >= 0)
            {
              reactor_atoms[other_atom].position = tunnel_one;
            }

            // SPECIAL EFFECT: swap beam and at least one tunnel flash
            // since the beam can take so many angles and lengths, I'll have
            // to build most of it in here
            if(color_this_time === RED_STR) mini_color = "red";
            else mini_color = "blue";
            sfx_text += "union\n{\n";
            sfx_text += "  intersection\n  {\n";
            sfx_text += "    object {" + mini_color + "_sfx_intersect}\n";
            sfx_text += "    object {quantum_tunnel_stick scale <0.5, 0.5, 1> translate ";
            sfx_text += origin_to_position_translates[tunnel_one] + "}\n  }\n";
            sfx_text += "  intersection\n  {\n";
            sfx_text += "    object {" + mini_color + "_sfx_intersect}\n";
            sfx_text += "    object {quantum_tunnel_stick scale <0.5, 0.5, 1> translate ";
            sfx_text += origin_to_position_translates[tunnel_other] + "}\n  }\n";
            if(flash_tunnel_one)
            {
              sfx_text += "  intersection\n  {\n";
              sfx_text += "    object {" + mini_color + "_sfx_intersect}\n";
              sfx_text += "    object {tunnel_flash_ring_stick}\n";
              sfx_text += "    translate ";
              sfx_text += origin_to_position_translates[tunnel_one];
              sfx_text += "\n  }\n";
            }
            if(flash_tunnel_other)
            {
              sfx_text += "  intersection\n  {\n";
              sfx_text += "    object {" + mini_color + "_sfx_intersect}\n";
              sfx_text += "    object {tunnel_flash_ring_stick}\n";
              sfx_text += "    translate ";
              sfx_text += origin_to_position_translates[tunnel_other];
              sfx_text += "\n  }\n";
            }
            sfx_text += "  intersection\n  {\n";
            sfx_text += "    difference\n    {\n";
            axis_horizontal = extract_x(origin_to_position_translates[tunnel_one],
              origin_to_position_translates[tunnel_other]);
            axis_vertical = extract_y(origin_to_position_translates[tunnel_one],
              origin_to_position_translates[tunnel_other]);
            if((axis_horizontal === null) || (axis_vertical === null))
            {
              // console_write("Error: math problem");
              error_write("math problem");
              return;
            }
            sfx_text += "      box {<0, -0.2, -10>, <sqrt(((" + axis_horizontal;
            sfx_text += ") * (" + axis_horizontal + ")) + ((" + axis_vertical;
            sfx_text += ") * (" + axis_vertical + "))), 0.2, 10>}\n";
            sfx_text += "      object {tunnel_bound_cylinder_stick}\n";
            sfx_text += "      object {tunnel_bound_cylinder_stick ";
            sfx_text += "translate sqrt(((";
            sfx_text += axis_horizontal + ") * (" + axis_horizontal + ")) + ((";
            sfx_text += axis_vertical + ") * (" + axis_vertical + "))) * x}\n";
            sfx_text += "      rotate degrees(atan2(" + axis_vertical;
            sfx_text += ", " + axis_horizontal + ")) * z\n";
            sfx_text += "      translate ";
            sfx_text += origin_to_position_translates[tunnel_one] + "\n    }\n";
            sfx_text += "    object {" + mini_color + "_sfx_intersect}\n  }\n";
            sfx_text += "  texture\n  {\n";
            sfx_text += "    pigment {rgbt <";
            if(color_this_time === RED_STR) sfx_text += "1, 0.025, 0.075";
            else sfx_text += "0.3, 0.3, 1";
            sfx_text += ", 0.5 + (0.5 * mod_clock)>}\n";
            sfx_text += "    finish {ambient 1}\n  }\n  no_shadow\n}\n";
          }
          // and put the DS_NONE status back in held atoms
          for(loop = 0; loop < the_waldos.length; ++loop)
          {
            // if it wasn't holding an atom at the start of this, it still isn't
            if(the_waldos[loop].hold_atom)
            {
              // it thinks it is holding an atom; see whether it really is
              one_atom = find_atom_index(the_waldos[loop].position, false);
              if(one_atom < 0)
              {
                // it isn't -- open the waldo
                the_waldos[loop].hold_atom = false;
              }
              else
              {
                // it is -- propagate DS_NONE
                if(!propagate(the_waldos[loop].position, current_cycle,
                  DS_NONE, 0))
                {
                  // console_write("Error: propagation noncooperation");
                  error_write("propagation noncooperation");
                  return;
                }
              }
            }
          }
        }
        else
        {
          // console_write("Error: that\'s not an instruction");
          error_write("that\'s not an instruction");
          return;
        }
      }  // end of instruction processing if(useful_thing >= 0)

    }  // end of waldo loop
    if(ultrabreak) break;

    // DS_DEPARTCONFIRM removal -- do it backward because of all the splices
    for(loop = (reactor_atoms.length - 1); loop >= 0; --loop)
    {
      if(reactor_atoms[loop].departure_status === DS_DEPARTCONFIRM)
      {
        reactor_atoms.splice(loop, 1);
      }
    }

    // atom next-state figuring-out
    // first, for any rotates, propagate the real rotation status, then
    // set any remaining prelims to WD_UNKNOWN
    for(waldo_loop = 0; waldo_loop < the_waldos.length; ++waldo_loop)
    {
      // let's see... if waldo is on a rotate, and its held atom has a prelim
      if(!the_waldos[waldo_loop].hold_atom) continue;
      if(waldo_loop === 0) color_this_time = RED_STR;
      else color_this_time = BLUE_STR;
      useful_thing = get_thing_index(the_waldos[waldo_loop].position,
        color_this_time, false);
      if(useful_thing < 0) continue;  // no instruction there
      if((reactor_things_array[useful_thing].object_type != ROT_CLOCK_STR) &&
        (reactor_things_array[useful_thing].object_type != ROT_CCLOCK_STR))
      {
        continue;  // not a rotate
      }
      useful_thing = find_atom_index(the_waldos[waldo_loop].position, false);
      if(useful_thing < 0)
      {
        // console_write("Error: oh no, we\'ve lost an atom!");
        error_write("oh no, we\'ve lost an atom!");
        return;
      }
      if((reactor_atoms[useful_thing].whatcha_doin != WD_ROTCLOCKPRELIM) &&
        (reactor_atoms[useful_thing].whatcha_doin != WD_ROTCOUNTERCLOCKPRELIM))
      {
        continue;  // must have done the rotate and is leaving this cycle
      }
      // propagate the real rotate
      if(reactor_atoms[useful_thing].whatcha_doin === WD_ROTCLOCKPRELIM)
      {
        more_useful = WD_ROTCLOCK;
      }
      else
      {
        more_useful = WD_ROTCOUNTERCLOCK;
      }
      if(!propagate(the_waldos[waldo_loop].position, current_cycle,
        more_useful, the_waldos[waldo_loop].position))
      {
        // console_write("Error: propagation motivation");
        error_write("propagation motivation");
        return;
      }
    }
    // the set-remaining-prelims part...
    for(loop = 0; loop < reactor_atoms.length; ++loop)
    {
      if((reactor_atoms[loop].whatcha_doin === WD_ROTCLOCKPRELIM) ||
        (reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCKPRELIM))
      {
        reactor_atoms[loop].whatcha_doin = WD_UNKNOWN;
      }
    }
    // now process whatever statuses they have
    for(waldo_loop = 0; waldo_loop < the_waldos.length; ++waldo_loop)
    {
      if(!the_waldos[waldo_loop].hold_atom) continue;
      if(the_waldos[waldo_loop].proceed)
      {
        // lateral or up-down movement
        if(the_waldos[waldo_loop].direction === UP_STR) useful_thing = WD_MOVEUP;
        else if(the_waldos[waldo_loop].direction === DOWN_STR) useful_thing = WD_MOVEDOWN;
        else if(the_waldos[waldo_loop].direction === LEFT_STR) useful_thing = WD_MOVELEFT;
        else if(the_waldos[waldo_loop].direction === RIGHT_STR) useful_thing = WD_MOVERIGHT;
        else
        {
          // console_write("Error: unexpected thing at the thing");
          error_write("unexpected thing at the thing");
          return;
        }
        one_atom = find_atom_index(the_waldos[waldo_loop].position, false);
        if(one_atom < 0)
        {
          // console_write("Error: butterfingers");
          error_write("butterfingers");
          return;
        }
        // if that atom already has a different status, reaction error
        if(reactor_atoms[one_atom].whatcha_doin === useful_thing) continue;
        if(reactor_atoms[one_atom].whatcha_doin != WD_UNKNOWN)
        {
          ultrabreak = true;
          error_text = "// WARNING: This reaction ends in an error.\n";
          error_text += "// See the output log at the top of the PovChem page for details.\n\n";
          text = (error_text + text);
          // error_text = "Warning: reaction ends in an error: atom or molecule ";
          error_text = "Reaction ends in an error: atom or molecule ";
          error_text += "pulled two different directions on cycle ";
          error_text += current_cycle;
          // console_write(error_text);
          warning_write(error_text);
          break;
        }
        // now that that's out of the way, propagate that status
        if(!propagate(the_waldos[waldo_loop].position, current_cycle,
          useful_thing, 0))
        {
          // console_write("Error: propagation problem");
          error_write("propagation problem");
          return;
        }
      }
      else
      {
        // rotation or stationary
        one_atom = find_atom_index(the_waldos[waldo_loop].position, false);
        if(one_atom < 0)
        {
          // console_write("Error: misplaced an atom");
          error_write("misplaced an atom");
          return;
        }
        if(waldo_loop === 0) color_this_time = RED_STR;
        else color_this_time = BLUE_STR;
        more_useful = "";
        useful_thing = get_thing_index(the_waldos[waldo_loop].position,
          color_this_time, false);
        if(useful_thing >= 0)
        {
          more_useful = reactor_things_array[useful_thing].object_type;
        }
        if((more_useful === ROT_CLOCK_STR) || (more_useful === ROT_CCLOCK_STR))
        {
          // a rotate
          // hmm, this will let two waldos rotating the same molecule the same
          // direction from the same position work, whereas Spacechem will
          // complain if you try that... I guess I'm okay with that.
          // make sure the atom's status matches -- rotation (and direction)
          // and axis position
          if(((more_useful === ROT_CLOCK_STR) &&
            (reactor_atoms[one_atom].whatcha_doin != WD_ROTCLOCK)) ||
            ((more_useful === ROT_CCLOCK_STR) &&
            (reactor_atoms[one_atom].whatcha_doin != WD_ROTCOUNTERCLOCK)) ||
            (reactor_atoms[one_atom].axis_position != the_waldos[waldo_loop].position))
          {
            // reaction error
            ultrabreak = true;
            error_text = "// WARNING: This reaction ends in an error.\n";
            error_text += "// See the output log at the top of the PovChem page for details.\n\n";
            text = (error_text + text);
            // error_text = "Warning: reaction ends in an error: atom or molecule";
            error_text = "Reaction ends in an error: atom or molecule";
            error_text += " twisted apart by a rotation on cycle ";
            error_text += current_cycle;
            // console_write(error_text);
            warning_write(error_text);
            break;
          }
        }
        else
        {
          // stationary -- make sure the status is WD_UNKNOWN or WD_NOTHING
          if((reactor_atoms[one_atom].whatcha_doin != WD_UNKNOWN) &&
            (reactor_atoms[one_atom].whatcha_doin != WD_NOTHING))
          {
            // reaction error
            ultrabreak = true;
            error_text = "// WARNING: This reaction ends in an error.\n";
            error_text += "// See the output log at the top of the PovChem page for details.\n\n";
            text = (error_text + text);
            // error_text = "Warning: reaction ends in an error: atom or molecule";
            error_text = "Reaction ends in an error: atom or molecule";
            error_text += " pulled apart on cycle " + current_cycle;
            // console_write(error_text);
            warning_write(error_text);
            break;
          }
          // ... and if it's WD_UNKNOWN, propagate WD_NOTHING
          if(reactor_atoms[one_atom].whatcha_doin === WD_UNKNOWN)
          {
            if(!propagate(the_waldos[waldo_loop].position,
              current_cycle, WD_NOTHING, 0))
            {
              // console_write("Error: propagation defenestration");
              error_write("propagation defenestration");
              return;
            }
          }
        }
      }
    }
    if(ultrabreak) break;
    // and now, from each atom's status, figure out its next position
    for(loop = 0; loop < reactor_atoms.length; ++loop)
    {
      // don't raise errors if a next position is out-of-bounds... the next
      // cycle will do that
      if((reactor_atoms[loop].whatcha_doin === WD_UNKNOWN) ||
        (reactor_atoms[loop].whatcha_doin === WD_NOTHING))
      {
        reactor_atoms[loop].next_position = reactor_atoms[loop].position;
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVELEFT)
      {
        reactor_atoms[loop].next_position = move_left(reactor_atoms[loop].position);
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVERIGHT)
      {
        reactor_atoms[loop].next_position = move_right(reactor_atoms[loop].position);
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVEUP)
      {
        reactor_atoms[loop].next_position = move_up(reactor_atoms[loop].position);
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVEDOWN)
      {
        reactor_atoms[loop].next_position = move_down(reactor_atoms[loop].position);
      }
      else if((reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK) ||
        (reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCK))
      {
        if(!validate_grid(reactor_atoms[loop].axis_position))
        {
          // console_write("Error: invalid axis");
          error_write("invalid axis");
          return;
        }
        // start by figuring out how far vertically and horizontally it is
        // from the axis to here
        axis_vertical = (Math.ceil(reactor_atoms[loop].position / 10) -
          Math.ceil(reactor_atoms[loop].axis_position / 10));
        axis_horizontal = ((reactor_atoms[loop].position - 1) % 10) -
          ((reactor_atoms[loop].axis_position - 1) % 10);
        // check the math
        if(move_far(move_far(reactor_atoms[loop].axis_position,
          axis_vertical, DOWN_STR), axis_horizontal, RIGHT_STR) !=
          reactor_atoms[loop].position)
        {
          // console_write("Error: basic arithmetic");
          error_write("basic arithmetic");
          return;
        }
        // figure out the new position
        if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
        {
          // clockwise rotation
          // new horizontal is negative of former vertical
          // new vertical is former horizontal
          reactor_atoms[loop].next_position = move_far(move_far(
            reactor_atoms[loop].axis_position, axis_horizontal, DOWN_STR),
            ((-1) * axis_vertical), RIGHT_STR);
        }
        else
        {
          // counterclockwise rotation
          // new horizontal is former vertical
          // new vertical is negative of former horizontal
          reactor_atoms[loop].next_position = move_far(move_far(
            reactor_atoms[loop].axis_position, ((-1) * axis_horizontal),
            DOWN_STR), axis_vertical, RIGHT_STR);
        }
      }
      else
      {
        // console_write("Error: invalid intentions");
        error_write("invalid intentions");
        return;
      }
    }
    // now that we know each atom's next position, we can figure out which,
    // if any, sensor redirects should light up on this cycle
    // useful_thing will be the atomic number of the (first found) atom on
    // the sensor
    useful_thing = 0;
    if(validate_grid(sensor_spot))
    {
      for(loop = 0; loop < reactor_atoms.length; ++loop)
      {
        if(reactor_atoms[loop].next_position === sensor_spot)
        {
          useful_thing = reactor_atoms[loop].atomic_number;
          break;
        }
      }
    }

    // update sensor redirects (flip flops will be updated after drawing)
    for(loop = 0; loop < reactor_things_array.length; ++loop)
    {
      if(reactor_things_array[loop].object_type === SENS_REDIR_STR)
      {
        reactor_things_array[loop].prev_state = reactor_things_array[loop].state;
        if(useful_thing === reactor_things_array[loop].atom)
        {
          reactor_things_array[loop].state = 1;
        }
        else
        {
          reactor_things_array[loop].state = 0;
        }
      }
    }

    // DRAWING STUFF

    provisional_text = "";

    // waldos
    for(loop = 0; loop < the_waldos.length; ++loop)
    {
      provisional_text += "object {";
      if(loop === 0) provisional_text += "red";
      else provisional_text += "blue";
      provisional_text += "_waldo_";
      if(the_waldos[loop].hold_atom) provisional_text += "closed";
      else provisional_text += "open";
      provisional_text += " translate ";
      provisional_text += origin_to_position_translates[the_waldos[loop].position];
      if(the_waldos[loop].proceed)
      {
        if(!validate_direction(the_waldos[loop].direction))
        {
          // console_write("Error: Really?  A bad direction all the way down here?");
          error_write("Really?  A bad direction all the way down here?");
          return;
        }
        provisional_text += " translate mod_clock * ";
        if(the_waldos[loop].direction === UP_STR) provisional_text += "y";
        else if(the_waldos[loop].direction === DOWN_STR) provisional_text += "(-y)";
        else if(the_waldos[loop].direction === RIGHT_STR) provisional_text += "x";
        else provisional_text += "(-x)";
      }
      provisional_text += "}\n";
    }

    // sensor redirects and flip flops
    for(loop = 0; loop < reactor_things_array.length; ++loop)
    {
      if((reactor_things_array[loop].object_type === SENS_REDIR_STR) ||
        (reactor_things_array[loop].object_type === FLIP_FLOP_STR))
      {
        // first the instruction ball
        if(reactor_things_array[loop].object_type === SENS_REDIR_STR)
        {
          provisional_text += "object {";
          if(reactor_things_array[loop].color === RED_STR) provisional_text += "red_";
          else provisional_text += "blue_";
          provisional_text += atom_pov_abbrev(reactor_things_array[loop].atom);
          provisional_text += "_sensor";
          if(reactor_things_array[loop].state === 0)
          {
            provisional_text += "_inactive";
          }
          provisional_text += " translate <-0.5, -0.5, 0> translate ";
          provisional_text += origin_to_position_translates[reactor_things_array[loop].location];
          provisional_text += "}\n";
        }
        else
        {
          provisional_text += "object {";
          if(reactor_things_array[loop].color === RED_STR) provisional_text += "red";
          else provisional_text += "blue";
          provisional_text += "_flip_flop_";
          if(reactor_things_array[loop].state === 0)
          {
            if(reactor_things_array[loop].prev_state === 0)
            {
              provisional_text += "off_flip";
            }
            else
            {
              provisional_text += "flop_to_flip";
              // now which way to flip (or flop)?
              if(reactor_things_array[loop].direction === DOWN_STR) provisional_text += "_down";
              else if(reactor_things_array[loop].direction === UP_STR) provisional_text += "_up";
              else if(reactor_things_array[loop].direction === LEFT_STR) provisional_text += "_left";
              else provisional_text += "_right";
            }
          }
          else
          {
            if(reactor_things_array[loop].prev_state === 0)
            {
              provisional_text += "flip_to_flop";
              // now which way to flop (or flip)?
              if(reactor_things_array[loop].direction === DOWN_STR) provisional_text += "_down";
              else if(reactor_things_array[loop].direction === UP_STR) provisional_text += "_up";
              else if(reactor_things_array[loop].direction === LEFT_STR) provisional_text += "_left";
              else provisional_text += "_right";
            }
            else
            {
              provisional_text += "on_flop";
            }
          }
          provisional_text += " translate <-0.5, -0.5, 0> translate ";
          provisional_text += origin_to_position_translates[reactor_things_array[loop].location];
          provisional_text += "}\n";
        }
        // now the arrow direction override
        if(reactor_things_array[loop].state === 0)
        {
          if(reactor_things_array[loop].prev_state != 0)
          {
            provisional_text += "object {";
            if(reactor_things_array[loop].color === RED_STR) provisional_text += "red";
            else provisional_text += "blue";
            provisional_text += "_indicator_contract_";
            if(reactor_things_array[loop].direction === DOWN_STR) provisional_text += "d";
            else if(reactor_things_array[loop].direction === UP_STR) provisional_text += "u";
            else if(reactor_things_array[loop].direction === LEFT_STR) provisional_text += "l";
            else provisional_text += "r";
            provisional_text += " translate <-0.5, -0.5, 0> translate ";
            provisional_text += origin_to_position_translates[reactor_things_array[loop].location];
            provisional_text += "}\n";
          }
        }
        else
        {
          provisional_text += "object {";
          if(reactor_things_array[loop].color === RED_STR) provisional_text += "red";
          else provisional_text += "blue";
          provisional_text += "_indicator_";
          if(reactor_things_array[loop].prev_state === 0)
          {
            provisional_text += "expand_";
          }
          if(reactor_things_array[loop].direction === DOWN_STR) provisional_text += "d";
          else if(reactor_things_array[loop].direction === UP_STR) provisional_text += "u";
          else if(reactor_things_array[loop].direction === LEFT_STR) provisional_text += "l";
          else provisional_text += "r";
          provisional_text += " translate <-0.5, -0.5, 0> translate ";
          provisional_text += origin_to_position_translates[reactor_things_array[loop].location];
          provisional_text += "}\n";
        }
      }
    }

    // update flip flops' prev_state
    for(loop = 0; loop < reactor_things_array.length; ++loop)
    {
      if(reactor_things_array[loop].object_type === FLIP_FLOP_STR)
      {
        reactor_things_array[loop].prev_state = reactor_things_array[loop].state;
      }
    }

    // atoms and bonds
    for(loop = 0; loop < reactor_atoms.length; ++loop)
    {
      if((isNaN(reactor_atoms[loop].atomic_number)) ||
        (reactor_atoms[loop].atomic_number < 1) ||
        (reactor_atoms[loop].atomic_number > 113) ||
        (Math.round(reactor_atoms[loop].atomic_number) !=
        reactor_atoms[loop].atomic_number))
      {
        // console_write("Error: bad atom way down here");
        error_write("bad atom way down here");
        return;
      }
      provisional_text += "union\n{\n";
      provisional_text += "  object {";
      provisional_text += atom_pov_abbrev(reactor_atoms[loop].atomic_number);
      provisional_text += "_atom}\n";
      // and its rightward and downward bonds
      if(reactor_atoms[loop].bond_right > 0)
      {
        provisional_text += "  object {";
        if(reactor_atoms[loop].bond_right === 1) provisional_text += "single";
        else if(reactor_atoms[loop].bond_right === 2) provisional_text += "double";
        else provisional_text += "triple";
        provisional_text += "_bond translate 0.5 * x";
        // if it's rotating, need to put the bond rotations in here, since
        // the atomic symbol stays level
        if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
        {
          provisional_text += " rotate -90 * mod_clock * z";
        }
        else if(reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCK)
        {
          provisional_text += " rotate 90 * mod_clock * z";
        }
        provisional_text += "}\n";
      }
      if(reactor_atoms[loop].bond_down > 0)
      {
        provisional_text += "  object {";
        if(reactor_atoms[loop].bond_down === 1) provisional_text += "single";
        else if(reactor_atoms[loop].bond_down === 2) provisional_text += "double";
        else provisional_text += "triple";
        provisional_text += "_bond translate 0.5 * x rotate -90 * z";
        // handle bond rotation for this one too
        if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
        {
          provisional_text += " rotate -90 * mod_clock * z";
        }
        else if(reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCK)
        {
          provisional_text += " rotate 90 * mod_clock * z";
        }
        provisional_text += "}\n";
      }
      // now, what's it doing?
      if((reactor_atoms[loop].whatcha_doin === WD_UNKNOWN) ||
        (reactor_atoms[loop].whatcha_doin === WD_NOTHING))
      {
        // crickets
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVELEFT)
      {
        provisional_text += "  translate mod_clock * (-x)\n";
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVERIGHT)
      {
        provisional_text += "  translate mod_clock * x\n";
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVEUP)
      {
        provisional_text += "  translate mod_clock * y\n";
      }
      else if(reactor_atoms[loop].whatcha_doin === WD_MOVEDOWN)
      {
        provisional_text += "  translate mod_clock * (-y)\n";
      }
      else if((reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK) ||
        (reactor_atoms[loop].whatcha_doin === WD_ROTCOUNTERCLOCK))
      {
        // this nonsense again...
        // so...
        // - figure out vertical and horizontal axis-to-atom distances,
        // - rotate the atom at origin the *other* way
        // - translate it axis-to-atom
        // - rotate it the correct way
        // - translate it negative axis-to-atom
        // - translate it origin-to-position
        // wanna check the math again? sure
        axis_vertical = (Math.ceil(reactor_atoms[loop].position / 10) -
          Math.ceil(reactor_atoms[loop].axis_position / 10));
        axis_horizontal = ((reactor_atoms[loop].position - 1) % 10) -
          ((reactor_atoms[loop].axis_position - 1) % 10);
        if(move_far(move_far(reactor_atoms[loop].axis_position,
          axis_vertical, DOWN_STR), axis_horizontal, RIGHT_STR) !=
          reactor_atoms[loop].position)
        {
          // console_write("Error: basic arithmetic, second semester");
          error_write("basic arithmetic, second semester");
          return;
        }
        // down the list... rotate the other way...
        if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
        {
          // left-handed rotate... +z into the scene... so +z is counterclock
          provisional_text += "  rotate mod_clock * 90 * z\n";
        }
        else
        {
          provisional_text += "  rotate mod_clock * 90 * (-z)\n";
        }
        // translate axis-to-atom
        provisional_text += "  translate <" + axis_horizontal;
        provisional_text += ", -(" + axis_vertical + "), 0>\n";
        // rotate it the correct way
        if(reactor_atoms[loop].whatcha_doin === WD_ROTCLOCK)
        {
          provisional_text += "  rotate mod_clock * 90 * (-z)\n";
        }
        else
        {
          provisional_text += "  rotate mod_clock * 90 * z\n";
        }
        // un-translate
        provisional_text += "  translate -(<" + axis_horizontal;
        provisional_text += ", -(" + axis_vertical + "), 0>)\n";
        // and translate origin to position is done outside this block
      }
      else
      {
        // console_write("Error: not sure what that one thinks it\'s doing");
        error_write("not sure what that one thinks it\'s doing");
        return;
      }
      provisional_text += "  translate ";
      provisional_text += origin_to_position_translates[reactor_atoms[loop].position];
      provisional_text += "\n}\n";
    }

    // reaction statistics
    // cycle count
    provisional_text += "text {ttf \"cyrvetic.ttf\" \"" + current_cycle;
    provisional_text += "\" 0.1, 0 scale 0.3 translate <6.01, -3.4, label_gr";
    provisional_text += "id_layer> texture {pigment {rgb 1} finish {ambient 1";
    provisional_text += "}} no_shadow}\n";
    // psi count
    provisional_text += "text {ttf \"cyrvetic.ttf\" \"" + psi_count + "\" 0.1";
    provisional_text += ", 0 scale 0.3 translate <5.45, -3.75, label_grid_lay";
    provisional_text += "er> texture {pigment {rgb 1} finish {ambient 1}} no_";
    provisional_text += "shadow}\n";
    // omega count
    if(!use_big_psi)
    {
      provisional_text += "text {ttf \"cyrvetic.ttf\" \"" + omega_count + "\"";
      provisional_text += " 0.1, 0 scale 0.3 translate <6.35, -3.75, label_gr";
      provisional_text += "id_layer> texture {pigment {rgb 1} finish {ambient";
      provisional_text += " 1}} no_shadow}\n";
    }

    // any special effects I didn't do back when they happened

    // update waldos' positions for next cycle
    for(loop = 0; loop < the_waldos.length; ++loop)
    {
      if(the_waldos[loop].proceed)
      {
        if(the_waldos[loop].direction === RIGHT_STR)
        {
          the_waldos[loop].position = move_right(the_waldos[loop].position);
        }
        else if(the_waldos[loop].direction === LEFT_STR)
        {
          the_waldos[loop].position = move_left(the_waldos[loop].position);
        }
        else if(the_waldos[loop].direction === DOWN_STR)
        {
          the_waldos[loop].position = move_down(the_waldos[loop].position);
        }
        else if(the_waldos[loop].direction === UP_STR)
        {
          the_waldos[loop].position = move_up(the_waldos[loop].position);
        }
        else
        {
          // console_write("Error: bad direction right here at the end");
          error_write("bad direction right here at the end");
          return;
        }
      }
    }

    // I guess I should add the provisional text to the main text
    provisional_text += sfx_text;
    text += provisional_text;
  }  // end of main reaction loop

  if(needs_an_end)
  {
    text += "\n#end\n";
  }

  // if no errors, set that as the scene text
  // and, if there were errors, we just returned straight from there, so
  scene_ref.value = text;

  if(!ultrabreak)
  {
    console_write("Reaction simulation finished.");
  }

  // and then write the ini text
  // if there was an ultrabreak, don't draw the last cycle
  if(ultrabreak) useful_thing = (current_cycle - 1);
  else useful_thing = current_cycle;
  more_useful = current_cycle * frames_per_cycle;

  text = "[Anim 1280x720]\n";
  text += "Quality=9\n";
  text += "Antialias_Depth=5\n";
  text += "Antialias=On\n";
  text += "Antialias_Threshold=0.05\n";
  text += "Jitter=Off\n";
  text += "+W1280 +H720\n";
  text += "Initial_Clock=0\n";
  text += "Final_Clock=" + useful_thing + "\n";
  text += "Initial_Frame=0\n";
  text += "Final_Frame=" + more_useful + "\n";
  text += "Subset_Start_Frame=0\n";
  text += "Subset_End_Frame=" + (more_useful - 1) + "\n\n";

  text += "[Anim 1920x1080]\n";
  text += "Quality=9\n";
  text += "Antialias_Depth=5\n";
  text += "Antialias=On\n";
  text += "Antialias_Threshold=0.05\n";
  text += "Jitter=Off\n";
  text += "+W1920 +H1080\n";
  text += "Initial_Clock=0\n";
  text += "Final_Clock=" + useful_thing + "\n";
  text += "Initial_Frame=0\n";
  text += "Final_Frame=" + more_useful + "\n";
  text += "Subset_Start_Frame=0\n";
  text += "Subset_End_Frame=" + (more_useful - 1) + "\n\n";

  text += "[Anim 4K holy crap]\n";
  text += "Quality=9\n";
  text += "Antialias_Depth=5\n";
  text += "Antialias=On\n";
  text += "Antialias_Threshold=0.05\n";
  text += "Jitter=Off\n";
  text += "+W3840 +H2160\n";
  text += "Initial_Clock=0\n";
  text += "Final_Clock=" + useful_thing + "\n";
  text += "Initial_Frame=0\n";
  text += "Final_Frame=" + more_useful + "\n";
  text += "Subset_Start_Frame=0\n";
  text += "Subset_End_Frame=" + (more_useful - 1) + "\n\n";

  text += "[Anim (test render) 640x360]\n";
  text += "Quality=1\n";
  text += "Antialias=Off\n";
  text += "Jitter=Off\n";
  text += "+W640 +H360\n";
  text += "Initial_Clock=0\n";
  text += "Final_Clock=" + useful_thing + "\n";
  text += "Initial_Frame=0\n";
  text += "Final_Frame=" + (useful_thing * 3) + "\n";
  text += "Subset_Start_Frame=0\n";
  text += "Subset_End_Frame=" + ((useful_thing * 3) - 1) + "\n\n";

  ini_ref.value = text;
}


// and after all that, a wrapper just to gray and un-gray a button
function gray_and_go()
{
  var gray_it_for_a_while;

  gray_it_for_a_while = document.getElementById("for_real_button");
  if(gray_it_for_a_while == null)
  {
    alert("oopsshh");
    return;
  }
  gray_it_for_a_while.setAttribute("disabled", "");

  // wrap
  holy_crap_here_we_go();
  // that's a wrap

  gray_it_for_a_while.removeAttribute("disabled");
}


function load_function()
{
  var loop;
  var id_string = "";
  var ref;
  var more_ref;
  var error_count = 0;

  // set some text colors in the reactor grid
  for(loop = 1; loop <= 80; ++loop)
  {
    id_string = "g";
    id_string += loop;
    id_string += "num";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else
    {
      ref.innerHTML = "";
      more_ref = document.createElement("a");
      // more_ref.setAttribute("href", "");
      more_ref.setAttribute("id", "grid_" + loop + "_link");
      more_ref.setAttribute("onclick", "grid_click_handler(this)");
      more_ref.innerHTML = (loop.toString());
      ref.appendChild(more_ref);
    }

    id_string = "g";
    id_string += loop;
    id_string += "red_u";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#c00000";

    id_string = "g";
    id_string += loop;
    id_string += "blue_u";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#0000ff";

    id_string = "g";
    id_string += loop;
    id_string += "red_l";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#c00000";

    id_string = "g";
    id_string += loop;
    id_string += "red_con";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#c00000";

    id_string = "g";
    id_string += loop;
    id_string += "reac";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;

    id_string = "g";
    id_string += loop;
    id_string += "red_r";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#c00000";

    id_string = "g";
    id_string += loop;
    id_string += "blue_l";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#0000ff";

    id_string = "g";
    id_string += loop;
    id_string += "blue_con";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#0000ff";

    id_string = "g";
    id_string += loop;
    id_string += "blue_r";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#0000ff";

    id_string = "g";
    id_string += loop;
    id_string += "red_d";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#c00000";

    id_string = "g";
    id_string += loop;
    id_string += "blue_d";
    ref = document.getElementById(id_string);
    if(ref == null) ++error_count;
    else ref.style.color = "#0000ff";
  }

  // populate all those atom selects
  var ref_array;
  var ref_loop;

  if((atom_abbrevs.length != atom_names.length) ||
    (atom_names.length != max_bonds.length))
  {
    ++error_count;
  }
  else
  {
    ref_array = document.getElementsByClassName("atom_select");
    for(ref_loop = 0; ref_loop < ref_array.length; ++ref_loop)
    {
      // selects in the molecule drawing tool need a "none" option; the
      // select in the grid controls does not
      if(ref_array[ref_loop].id != "input_atom_select")
      {
        ref = document.createElement("option");
        // ref.text = "(none)";  // turns out simply blank is better
        ref_array[ref_loop].add(ref);
      }

      // now add all the elements
      for(loop = 0; loop < atom_names.length; ++loop)
      {
        if(loop == 0) continue;

        ref = document.createElement("option");
        id_string = "";
        id_string += ((loop <= 109) ? (loop) : ("???"));
        id_string += " ";
        id_string += atom_abbrevs[loop];

        // that's all for most of them, but the one in the grid controls
        // gets the long-form version
        if(ref_array[ref_loop].id == "input_atom_select")
        {
          id_string += " ";
          id_string += atom_names[loop];
          // id_string += " (mb: ";
          id_string += ((loop == 1) ? (" (max. bonds: ") : (" (mb: "));
          id_string += max_bonds[loop];
          id_string += ")";
        }

        ref.text = id_string;
        ref_array[ref_loop].add(ref);
      }
    }
  }

  // click the "Clear" button to place the initial starting controls
  ref = document.getElementById("clear_grid_button");
  if(ref == null)
  {
    ++error_count;
  }
  else
  {
    ref.click();
  }

  if(error_count != 0)
  {
    // console_write("Oh no!  Errors!");
    error_write("Oh no!  Errors!");
  }
  else
  {
    console_write("Page loaded successfully.");
  }

  molecule_draw_clear_function();
  verify_molecule();

  number_prettifier();
}


// let's try to make it more clear which cell is selected
function number_prettifier()
{
  var input_ref;
  var cell_ref;
  var loop;
  var string_thing;

  input_ref = document.getElementById("input_grid_number");
  if(input_ref == null)
  {
    // console_write("Error: beautification resisted.");
    error_write("beautification resisted.");
    return;
  }

  if(isNaN(input_ref.value))
  {
    input_ref.value = 1;
    number_prettifier();
    return;
  }

  if(input_ref.value < 1)
  {
    input_ref.value = 1;
    number_prettifier();
    return;
  }

  if(input_ref.value > 80)
  {
    input_ref.value = 80;
    number_prettifier();
    return;
  }

  if(Math.round(input_ref.value) != input_ref.value)
  {
    input_ref.value = Math.round(input_ref.value);
    number_prettifier();
    return;
  }

  for(loop = 1; loop <= 80; ++loop)
  {
    string_thing = "g";
    string_thing += loop;
    string_thing += "num";

    cell_ref = document.getElementById(string_thing);
    if(cell_ref == null)
    {
      // string_thing = "Error: prettiness resisted at cell ";
      string_thing = "prettiness resisted at cell ";
      string_thing += loop;
      string_thing += ".";
      // console_write(string_thing);
      error_write(string_thing);
      return;
    }

    cell_ref.style.color = "inherit";
    cell_ref.style.backgroundColor = "inherit";
  }

  string_thing = "g";
  string_thing += input_ref.value;
  string_thing += "num";

  cell_ref = document.getElementById(string_thing);
  if(cell_ref == null)
  {
    // string_thing = "Error: prettiness resisted at current cell: ";
    string_thing = "prettiness resisted at current cell: ";
    string_thing += input_ref.value;
    string_thing += ".";
    // console_write(string_thing);
    error_write(string_thing);
    return;
  }

  cell_ref.style.color = "#FFFFFF";
  cell_ref.style.backgroundColor = "#000000";
}


// let's make warnings and errors more prominent
function warning_write(shame)
{
  if(typeof(shame) !== typeof(""))
  {
    warning_write("warning_write() called with a bad parameter... my fault.");
    return;
  }

  if(shame.length === 0)
  {
    warning_write("Unspecified reason... so, general anxiety.");
    return;
  }

  // clear any warning or error timer about to go off...
  clearTimeout(warning_error_timer_ref);

  // change the background to an unsettling yellow
  document.body.style.backgroundColor = "#FFFF00";

  // set the timer to change it back
  warning_error_timer_ref = setTimeout(reset_background, 400);

  // and write the message
  console_write("Warning: " + shame);
}

function error_write(shame)
{
  if(typeof(shame) !== typeof(""))
  {
    error_write("error_write() called with a bad parameter... my fault.");
    return;
  }

  if(shame.length === 0)
  {
    error_write("Unspecified reason... so panicking is suggested.");
    return;
  }

  // clear any warning or error timer about to go off...
  clearTimeout(warning_error_timer_ref);

  // change the background to an alarming red
  document.body.style.backgroundColor = "#FF0000";

  // set the timer to change it back
  warning_error_timer_ref = setTimeout(reset_background, 400);

  // and write the message
  console_write("Error: " + shame);
}

function reset_background()
{
  document.body.style.backgroundColor = "#FFFFFF";
}

function warning_test()
{
  warning_write("Test warning; no action needed.");
}

function error_test()
{
  error_write("Test error; no action needed.");
}


// some functions to help make the input sequence interface better
function alpha_sequence_redraw()
{
  var ref;
  var loop;
  var string_a_long;

  ref = document.getElementById("alpha_sequence");
  if(ref == null)
  {
    error_write("bad id in alpha_sequence_redraw()");
    return;
  }

  string_a_long = "";
  for(loop = 0; loop < alpha_sequence_array.length; ++loop)
  {
    if(loop > 0)
    {
      if(alpha_sequence_array[loop - 1] != alpha_sequence_array[loop])
      {
        string_a_long += "\n";
      }
      else
      {
        string_a_long += " ";
      }
    }
    string_a_long += "(";
    string_a_long += (loop + 1);
    string_a_long += " ";
    string_a_long += alpha_sequence_array[loop];
    string_a_long += ")";
  }
  ref.value = string_a_long;
}

function beta_sequence_redraw()
{
  var ref;
  var loop;
  var string_a_long;

  ref = document.getElementById("beta_sequence");
  if(ref == null)
  {
    error_write("bad id in beta_sequence_redraw()");
    return;
  }

  string_a_long = "";
  for(loop = 0; loop < beta_sequence_array.length; ++loop)
  {
    if(loop > 0)
    {
      if(beta_sequence_array[loop - 1] != beta_sequence_array[loop])
      {
        string_a_long += "\n";
      }
      else
      {
        string_a_long += " ";
      }
    }
    string_a_long += "(";
    string_a_long += (loop + 1);
    string_a_long += " ";
    string_a_long += beta_sequence_array[loop];
    string_a_long += ")";
  }
  ref.value = string_a_long;
}

function alpha_pop()
{
  if(alpha_sequence_array.length > 0)
  {
    --(alpha_sequence_array.length);
    alpha_sequence_redraw();
    // console_write("Removed a symbol from \u03b1 sequence.");
  }
}

function beta_pop()
{
  if(beta_sequence_array.length > 0)
  {
    --(beta_sequence_array.length);
    beta_sequence_redraw();
    // console_write("Removed a symbol from \u03b2 sequence.");
  }
}

function clear_alpha_seq_fn()
{
  alpha_sequence_array.length = 0;
  alpha_sequence_redraw();
  console_write("Cleared \u03b1 sequence.");
}

function clear_beta_seq_fn()
{
  beta_sequence_array.length = 0;
  beta_sequence_redraw();
  console_write("Cleared \u03b2 sequence.");
}

function clear_alpha_mol_fn()
{
  var one_ref;
  var two_ref;
  var three_ref;

  one_ref = document.getElementById("a1_span");
  two_ref = document.getElementById("a2_span");
  three_ref = document.getElementById("a3_span");

  if((one_ref == null) || (two_ref == null) ||
    (three_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  molecule_a1.length = 0;
  molecule_a2.length = 0;
  molecule_a3.length = 0;
  one_ref.innerHTML = "";
  two_ref.innerHTML = "";
  three_ref.innerHTML = "";
  console_write("Cleared \u03b1 molecules.");
}

function clear_beta_mol_fn()
{
  var one_ref;
  var two_ref;
  var three_ref;

  one_ref = document.getElementById("b1_span");
  two_ref = document.getElementById("b2_span");
  three_ref = document.getElementById("b3_span");

  if((one_ref == null) || (two_ref == null) ||
    (three_ref == null))
  {
    // console_write("Error: bad id");
    error_write("bad id");
    return;
  }
  molecule_b1.length = 0;
  molecule_b2.length = 0;
  molecule_b3.length = 0;
  one_ref.innerHTML = "";
  two_ref.innerHTML = "";
  three_ref.innerHTML = "";
  console_write("Cleared \u03b2 molecules.");
}

</script>

</head>
<body style = "background-color:#ffffff;color:#000000" onload = "load_function()">
<div><h2>PovChem!</h2></div>

<div><h3>Create POV-Ray animations of your Spacechem solutions!</h3></div>

<div>
Not quite automatically, though; you're going to have to enter your solution below.  And the interface is bad; I'll just prepare you for that now.<br><br>

<span style = "font-size:small">(There's a small <a href = "#gallery">gallery</a> at the end of this page if you're just here to see what it can do.)</span><br><br>

Anyway, To get a nice POV-Ray animation of your Spacechem solution you'll enter it here and the page will run it through the same process it would get in the game... almost.  There are a few differences, mostly for simplicity's sake:<br>
<ul>
  <li>Some Spacechem solutions may not work here, namely some that depend on certain things happening in a certain order within the same cycle (i.e. bonder priority).</li>
  <li>Some solutions that work here may not work in Spacechem.  For instance, there's hardly any collision detection here.  Here you could animate atoms going through each other or rotating outside the reactor walls and the simulation wouldn't care as long as they all ended up back inside on unoccupied squares for the next cycle.</li>
  <li>If you send multiple separate molecules through a single output with a single output instruction, molecule departure order here may differ from that in Spacechem.</li>
  <li>Probably other minor things, too.  Not too much, though, I think.</li>
</ul>
<br><br>

To start, you will need the following:
<ul>
  <li>Spacechem.  None of this makes any sense at all without that, does it?</li>
  <li><a href = "http://www.povray.org/" target = "_blank">The Persistence of Vision Ray Tracer</a></li>
  <li>The "cyrvetic.ttf" truetype font.  I'm pretty sure it comes with POV-Ray.</li>
  <li>The "times.ttf" truetype font in some location that POV-Ray checks.  Probably all of you already have this.  I sure hope it's the same one I have, because some letter positioning depends on it.
    <ul>
      <li>See the <a href = "#font_troubleshooting">troubleshooting</a> section for an alternate font that can be used.</li>
    </ul>
  </li>
  <li><a href = "povchem.inc">This include file</a> (right-click, "save as").  When you get your scene files, below, they will need this.  Put it somewhere your scene files can find it.</li>
  <li>Javascript.  All the neat stuff that this page does happens in javascript.  If you're the sort that disables all javascript on the pages you visit, well, I can't blame you, but this page will be useless to you unless you make an exception.</li>
  <li>Some video editing software and knowledge of how to use it.</li>
  <li>Patience.  You will likely wait a very long time while your animation renders.</li>
</ul>
<br><br>

How to use this thing:
<ol>
  <li>In section 1, replicate your solution's waldo programs and the placement of your reactor devices such as bonders, sensors, etc., on the reactor grid.  This is, admittedly, the worst of this interface, but perhaps it's best to get that over with quickly.</li>
  <li>In section 2, create molecules and assign them to input sequences and output labels.  (Technically, a single atom in a single molecule in a single input sequence is all that is needed to successfully create the bare minimum animated scene.)</li>
  <li>In section 3, generate and render a preview to make sure you've set everything as you expect, or set simulation and animation parameters and generate the full animated scene for your solution.</li>
</ol>
And in all cases, if you press a button and nothing or something other than what you expect happens, scroll way back up to the output log for some possibly useful information.
<br><br>
Check the <a href = "#gallery">gallery</a> at the end of this page for a walkthrough video.
<br><br>
To reset absolutely everything, reload this page.  On Firefox, you may need to do a hard refresh (Ctrl-F5).
</div>

<hr>

<div>
An output log of what's been happening.  Check back up here if something seems to go wrong:<br>
<table border = "0" cellpadding = "0" cellspacing = "0"><tbody>
  <tr>
    <td style = "vertical-align:top">
      <textarea id = "console_output" cols="80" rows="15" readonly></textarea>
    </td>
    <td style = "padding-left:10px;vertical-align:top;text-align:left">
      The background will flash briefly on warnings and errors.  Try it now:<br>
      <button onclick = "warning_test()">Test Warning</button><br>
      <button onclick = "error_test()">Test Error</button>
    </td>
  </tr>
</tbody></table>
</div>

<hr>

<div>
<b>Section 1:</b> Place reactor devices and add waldo instructions in this section.  Make it look like the solution you're trying to replicate, at least as well as it can on this HTML grid.
<br><br>
Click on a grid number to quickly select that cell.
<br><br>
What the grid currently looks like:<br>
<table border = 1 cellspacing = 0 cellpadding = 2>
<tbody>

  <tr>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g1num">1</td><td id = "g1red_u"></td><td id = "g1blue_u"></td><td></td></tr>
        <tr><td id = "g1red_l"></td><td id = "g1red_con"></td><td id = "g1reac"></td><td id = "g1red_r"></td></tr>
        <tr><td id = "g1blue_l"></td><td></td><td id = "g1blue_con"></td><td id = "g1blue_r"></td></tr>
        <tr><td></td><td id = "g1red_d"></td><td id = "g1blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g2num">2</td><td id = "g2red_u"></td><td id = "g2blue_u"></td><td></td></tr>
        <tr><td id = "g2red_l"></td><td id = "g2red_con"></td><td id = "g2reac"></td><td id = "g2red_r"></td></tr>
        <tr><td id = "g2blue_l"></td><td></td><td id = "g2blue_con"></td><td id = "g2blue_r"></td></tr>
        <tr><td></td><td id = "g2red_d"></td><td id = "g2blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g3num">3</td><td id = "g3red_u"></td><td id = "g3blue_u"></td><td></td></tr>
        <tr><td id = "g3red_l"></td><td id = "g3red_con"></td><td id = "g3reac"></td><td id = "g3red_r"></td></tr>
        <tr><td id = "g3blue_l"></td><td></td><td id = "g3blue_con"></td><td id = "g3blue_r"></td></tr>
        <tr><td></td><td id = "g3red_d"></td><td id = "g3blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g4num">4</td><td id = "g4red_u"></td><td id = "g4blue_u"></td><td></td></tr>
        <tr><td id = "g4red_l"></td><td id = "g4red_con"></td><td id = "g4reac"></td><td id = "g4red_r"></td></tr>
        <tr><td id = "g4blue_l"></td><td></td><td id = "g4blue_con"></td><td id = "g4blue_r"></td></tr>
        <tr><td></td><td id = "g4red_d"></td><td id = "g4blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g5num">5</td><td id = "g5red_u"></td><td id = "g5blue_u"></td><td></td></tr>
        <tr><td id = "g5red_l"></td><td id = "g5red_con"></td><td id = "g5reac"></td><td id = "g5red_r"></td></tr>
        <tr><td id = "g5blue_l"></td><td></td><td id = "g5blue_con"></td><td id = "g5blue_r"></td></tr>
        <tr><td></td><td id = "g5red_d"></td><td id = "g5blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g6num">6</td><td id = "g6red_u"></td><td id = "g6blue_u"></td><td></td></tr>
        <tr><td id = "g6red_l"></td><td id = "g6red_con"></td><td id = "g6reac"></td><td id = "g6red_r"></td></tr>
        <tr><td id = "g6blue_l"></td><td></td><td id = "g6blue_con"></td><td id = "g6blue_r"></td></tr>
        <tr><td></td><td id = "g6red_d"></td><td id = "g6blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g7num">7</td><td id = "g7red_u"></td><td id = "g7blue_u"></td><td></td></tr>
        <tr><td id = "g7red_l"></td><td id = "g7red_con"></td><td id = "g7reac"></td><td id = "g7red_r"></td></tr>
        <tr><td id = "g7blue_l"></td><td></td><td id = "g7blue_con"></td><td id = "g7blue_r"></td></tr>
        <tr><td></td><td id = "g7red_d"></td><td id = "g7blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g8num">8</td><td id = "g8red_u"></td><td id = "g8blue_u"></td><td></td></tr>
        <tr><td id = "g8red_l"></td><td id = "g8red_con"></td><td id = "g8reac"></td><td id = "g8red_r"></td></tr>
        <tr><td id = "g8blue_l"></td><td></td><td id = "g8blue_con"></td><td id = "g8blue_r"></td></tr>
        <tr><td></td><td id = "g8red_d"></td><td id = "g8blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g9num">9</td><td id = "g9red_u"></td><td id = "g9blue_u"></td><td></td></tr>
        <tr><td id = "g9red_l"></td><td id = "g9red_con"></td><td id = "g9reac"></td><td id = "g9red_r"></td></tr>
        <tr><td id = "g9blue_l"></td><td></td><td id = "g9blue_con"></td><td id = "g9blue_r"></td></tr>
        <tr><td></td><td id = "g9red_d"></td><td id = "g9blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g10num">10</td><td id = "g10red_u"></td><td id = "g10blue_u"></td><td></td></tr>
        <tr><td id = "g10red_l"></td><td id = "g10red_con"></td><td id = "g10reac"></td><td id = "g10red_r"></td></tr>
        <tr><td id = "g10blue_l"></td><td></td><td id = "g10blue_con"></td><td id = "g10blue_r"></td></tr>
        <tr><td></td><td id = "g10red_d"></td><td id = "g10blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g11num">11</td><td id = "g11red_u"></td><td id = "g11blue_u"></td><td></td></tr>
        <tr><td id = "g11red_l"></td><td id = "g11red_con"></td><td id = "g11reac"></td><td id = "g11red_r"></td></tr>
        <tr><td id = "g11blue_l"></td><td></td><td id = "g11blue_con"></td><td id = "g11blue_r"></td></tr>
        <tr><td></td><td id = "g11red_d"></td><td id = "g11blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g12num">12</td><td id = "g12red_u"></td><td id = "g12blue_u"></td><td></td></tr>
        <tr><td id = "g12red_l"></td><td id = "g12red_con"></td><td id = "g12reac"></td><td id = "g12red_r"></td></tr>
        <tr><td id = "g12blue_l"></td><td></td><td id = "g12blue_con"></td><td id = "g12blue_r"></td></tr>
        <tr><td></td><td id = "g12red_d"></td><td id = "g12blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g13num">13</td><td id = "g13red_u"></td><td id = "g13blue_u"></td><td></td></tr>
        <tr><td id = "g13red_l"></td><td id = "g13red_con"></td><td id = "g13reac"></td><td id = "g13red_r"></td></tr>
        <tr><td id = "g13blue_l"></td><td></td><td id = "g13blue_con"></td><td id = "g13blue_r"></td></tr>
        <tr><td></td><td id = "g13red_d"></td><td id = "g13blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g14num">14</td><td id = "g14red_u"></td><td id = "g14blue_u"></td><td></td></tr>
        <tr><td id = "g14red_l"></td><td id = "g14red_con"></td><td id = "g14reac"></td><td id = "g14red_r"></td></tr>
        <tr><td id = "g14blue_l"></td><td></td><td id = "g14blue_con"></td><td id = "g14blue_r"></td></tr>
        <tr><td></td><td id = "g14red_d"></td><td id = "g14blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g15num">15</td><td id = "g15red_u"></td><td id = "g15blue_u"></td><td></td></tr>
        <tr><td id = "g15red_l"></td><td id = "g15red_con"></td><td id = "g15reac"></td><td id = "g15red_r"></td></tr>
        <tr><td id = "g15blue_l"></td><td></td><td id = "g15blue_con"></td><td id = "g15blue_r"></td></tr>
        <tr><td></td><td id = "g15red_d"></td><td id = "g15blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g16num">16</td><td id = "g16red_u"></td><td id = "g16blue_u"></td><td></td></tr>
        <tr><td id = "g16red_l"></td><td id = "g16red_con"></td><td id = "g16reac"></td><td id = "g16red_r"></td></tr>
        <tr><td id = "g16blue_l"></td><td></td><td id = "g16blue_con"></td><td id = "g16blue_r"></td></tr>
        <tr><td></td><td id = "g16red_d"></td><td id = "g16blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g17num">17</td><td id = "g17red_u"></td><td id = "g17blue_u"></td><td></td></tr>
        <tr><td id = "g17red_l"></td><td id = "g17red_con"></td><td id = "g17reac"></td><td id = "g17red_r"></td></tr>
        <tr><td id = "g17blue_l"></td><td></td><td id = "g17blue_con"></td><td id = "g17blue_r"></td></tr>
        <tr><td></td><td id = "g17red_d"></td><td id = "g17blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g18num">18</td><td id = "g18red_u"></td><td id = "g18blue_u"></td><td></td></tr>
        <tr><td id = "g18red_l"></td><td id = "g18red_con"></td><td id = "g18reac"></td><td id = "g18red_r"></td></tr>
        <tr><td id = "g18blue_l"></td><td></td><td id = "g18blue_con"></td><td id = "g18blue_r"></td></tr>
        <tr><td></td><td id = "g18red_d"></td><td id = "g18blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g19num">19</td><td id = "g19red_u"></td><td id = "g19blue_u"></td><td></td></tr>
        <tr><td id = "g19red_l"></td><td id = "g19red_con"></td><td id = "g19reac"></td><td id = "g19red_r"></td></tr>
        <tr><td id = "g19blue_l"></td><td></td><td id = "g19blue_con"></td><td id = "g19blue_r"></td></tr>
        <tr><td></td><td id = "g19red_d"></td><td id = "g19blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g20num">20</td><td id = "g20red_u"></td><td id = "g20blue_u"></td><td></td></tr>
        <tr><td id = "g20red_l"></td><td id = "g20red_con"></td><td id = "g20reac"></td><td id = "g20red_r"></td></tr>
        <tr><td id = "g20blue_l"></td><td></td><td id = "g20blue_con"></td><td id = "g20blue_r"></td></tr>
        <tr><td></td><td id = "g20red_d"></td><td id = "g20blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g21num">21</td><td id = "g21red_u"></td><td id = "g21blue_u"></td><td></td></tr>
        <tr><td id = "g21red_l"></td><td id = "g21red_con"></td><td id = "g21reac"></td><td id = "g21red_r"></td></tr>
        <tr><td id = "g21blue_l"></td><td></td><td id = "g21blue_con"></td><td id = "g21blue_r"></td></tr>
        <tr><td></td><td id = "g21red_d"></td><td id = "g21blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g22num">22</td><td id = "g22red_u"></td><td id = "g22blue_u"></td><td></td></tr>
        <tr><td id = "g22red_l"></td><td id = "g22red_con"></td><td id = "g22reac"></td><td id = "g22red_r"></td></tr>
        <tr><td id = "g22blue_l"></td><td></td><td id = "g22blue_con"></td><td id = "g22blue_r"></td></tr>
        <tr><td></td><td id = "g22red_d"></td><td id = "g22blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g23num">23</td><td id = "g23red_u"></td><td id = "g23blue_u"></td><td></td></tr>
        <tr><td id = "g23red_l"></td><td id = "g23red_con"></td><td id = "g23reac"></td><td id = "g23red_r"></td></tr>
        <tr><td id = "g23blue_l"></td><td></td><td id = "g23blue_con"></td><td id = "g23blue_r"></td></tr>
        <tr><td></td><td id = "g23red_d"></td><td id = "g23blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g24num">24</td><td id = "g24red_u"></td><td id = "g24blue_u"></td><td></td></tr>
        <tr><td id = "g24red_l"></td><td id = "g24red_con"></td><td id = "g24reac"></td><td id = "g24red_r"></td></tr>
        <tr><td id = "g24blue_l"></td><td></td><td id = "g24blue_con"></td><td id = "g24blue_r"></td></tr>
        <tr><td></td><td id = "g24red_d"></td><td id = "g24blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g25num">25</td><td id = "g25red_u"></td><td id = "g25blue_u"></td><td></td></tr>
        <tr><td id = "g25red_l"></td><td id = "g25red_con"></td><td id = "g25reac"></td><td id = "g25red_r"></td></tr>
        <tr><td id = "g25blue_l"></td><td></td><td id = "g25blue_con"></td><td id = "g25blue_r"></td></tr>
        <tr><td></td><td id = "g25red_d"></td><td id = "g25blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g26num">26</td><td id = "g26red_u"></td><td id = "g26blue_u"></td><td></td></tr>
        <tr><td id = "g26red_l"></td><td id = "g26red_con"></td><td id = "g26reac"></td><td id = "g26red_r"></td></tr>
        <tr><td id = "g26blue_l"></td><td></td><td id = "g26blue_con"></td><td id = "g26blue_r"></td></tr>
        <tr><td></td><td id = "g26red_d"></td><td id = "g26blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g27num">27</td><td id = "g27red_u"></td><td id = "g27blue_u"></td><td></td></tr>
        <tr><td id = "g27red_l"></td><td id = "g27red_con"></td><td id = "g27reac"></td><td id = "g27red_r"></td></tr>
        <tr><td id = "g27blue_l"></td><td></td><td id = "g27blue_con"></td><td id = "g27blue_r"></td></tr>
        <tr><td></td><td id = "g27red_d"></td><td id = "g27blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g28num">28</td><td id = "g28red_u"></td><td id = "g28blue_u"></td><td></td></tr>
        <tr><td id = "g28red_l"></td><td id = "g28red_con"></td><td id = "g28reac"></td><td id = "g28red_r"></td></tr>
        <tr><td id = "g28blue_l"></td><td></td><td id = "g28blue_con"></td><td id = "g28blue_r"></td></tr>
        <tr><td></td><td id = "g28red_d"></td><td id = "g28blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g29num">29</td><td id = "g29red_u"></td><td id = "g29blue_u"></td><td></td></tr>
        <tr><td id = "g29red_l"></td><td id = "g29red_con"></td><td id = "g29reac"></td><td id = "g29red_r"></td></tr>
        <tr><td id = "g29blue_l"></td><td></td><td id = "g29blue_con"></td><td id = "g29blue_r"></td></tr>
        <tr><td></td><td id = "g29red_d"></td><td id = "g29blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g30num">30</td><td id = "g30red_u"></td><td id = "g30blue_u"></td><td></td></tr>
        <tr><td id = "g30red_l"></td><td id = "g30red_con"></td><td id = "g30reac"></td><td id = "g30red_r"></td></tr>
        <tr><td id = "g30blue_l"></td><td></td><td id = "g30blue_con"></td><td id = "g30blue_r"></td></tr>
        <tr><td></td><td id = "g30red_d"></td><td id = "g30blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g31num">31</td><td id = "g31red_u"></td><td id = "g31blue_u"></td><td></td></tr>
        <tr><td id = "g31red_l"></td><td id = "g31red_con"></td><td id = "g31reac"></td><td id = "g31red_r"></td></tr>
        <tr><td id = "g31blue_l"></td><td></td><td id = "g31blue_con"></td><td id = "g31blue_r"></td></tr>
        <tr><td></td><td id = "g31red_d"></td><td id = "g31blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g32num">32</td><td id = "g32red_u"></td><td id = "g32blue_u"></td><td></td></tr>
        <tr><td id = "g32red_l"></td><td id = "g32red_con"></td><td id = "g32reac"></td><td id = "g32red_r"></td></tr>
        <tr><td id = "g32blue_l"></td><td></td><td id = "g32blue_con"></td><td id = "g32blue_r"></td></tr>
        <tr><td></td><td id = "g32red_d"></td><td id = "g32blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g33num">33</td><td id = "g33red_u"></td><td id = "g33blue_u"></td><td></td></tr>
        <tr><td id = "g33red_l"></td><td id = "g33red_con"></td><td id = "g33reac"></td><td id = "g33red_r"></td></tr>
        <tr><td id = "g33blue_l"></td><td></td><td id = "g33blue_con"></td><td id = "g33blue_r"></td></tr>
        <tr><td></td><td id = "g33red_d"></td><td id = "g33blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g34num">34</td><td id = "g34red_u"></td><td id = "g34blue_u"></td><td></td></tr>
        <tr><td id = "g34red_l"></td><td id = "g34red_con"></td><td id = "g34reac"></td><td id = "g34red_r"></td></tr>
        <tr><td id = "g34blue_l"></td><td></td><td id = "g34blue_con"></td><td id = "g34blue_r"></td></tr>
        <tr><td></td><td id = "g34red_d"></td><td id = "g34blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g35num">35</td><td id = "g35red_u"></td><td id = "g35blue_u"></td><td></td></tr>
        <tr><td id = "g35red_l"></td><td id = "g35red_con"></td><td id = "g35reac"></td><td id = "g35red_r"></td></tr>
        <tr><td id = "g35blue_l"></td><td></td><td id = "g35blue_con"></td><td id = "g35blue_r"></td></tr>
        <tr><td></td><td id = "g35red_d"></td><td id = "g35blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g36num">36</td><td id = "g36red_u"></td><td id = "g36blue_u"></td><td></td></tr>
        <tr><td id = "g36red_l"></td><td id = "g36red_con"></td><td id = "g36reac"></td><td id = "g36red_r"></td></tr>
        <tr><td id = "g36blue_l"></td><td></td><td id = "g36blue_con"></td><td id = "g36blue_r"></td></tr>
        <tr><td></td><td id = "g36red_d"></td><td id = "g36blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g37num">37</td><td id = "g37red_u"></td><td id = "g37blue_u"></td><td></td></tr>
        <tr><td id = "g37red_l"></td><td id = "g37red_con"></td><td id = "g37reac"></td><td id = "g37red_r"></td></tr>
        <tr><td id = "g37blue_l"></td><td></td><td id = "g37blue_con"></td><td id = "g37blue_r"></td></tr>
        <tr><td></td><td id = "g37red_d"></td><td id = "g37blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g38num">38</td><td id = "g38red_u"></td><td id = "g38blue_u"></td><td></td></tr>
        <tr><td id = "g38red_l"></td><td id = "g38red_con"></td><td id = "g38reac"></td><td id = "g38red_r"></td></tr>
        <tr><td id = "g38blue_l"></td><td></td><td id = "g38blue_con"></td><td id = "g38blue_r"></td></tr>
        <tr><td></td><td id = "g38red_d"></td><td id = "g38blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g39num">39</td><td id = "g39red_u"></td><td id = "g39blue_u"></td><td></td></tr>
        <tr><td id = "g39red_l"></td><td id = "g39red_con"></td><td id = "g39reac"></td><td id = "g39red_r"></td></tr>
        <tr><td id = "g39blue_l"></td><td></td><td id = "g39blue_con"></td><td id = "g39blue_r"></td></tr>
        <tr><td></td><td id = "g39red_d"></td><td id = "g39blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g40num">40</td><td id = "g40red_u"></td><td id = "g40blue_u"></td><td></td></tr>
        <tr><td id = "g40red_l"></td><td id = "g40red_con"></td><td id = "g40reac"></td><td id = "g40red_r"></td></tr>
        <tr><td id = "g40blue_l"></td><td></td><td id = "g40blue_con"></td><td id = "g40blue_r"></td></tr>
        <tr><td></td><td id = "g40red_d"></td><td id = "g40blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g41num">41</td><td id = "g41red_u"></td><td id = "g41blue_u"></td><td></td></tr>
        <tr><td id = "g41red_l"></td><td id = "g41red_con"></td><td id = "g41reac"></td><td id = "g41red_r"></td></tr>
        <tr><td id = "g41blue_l"></td><td></td><td id = "g41blue_con"></td><td id = "g41blue_r"></td></tr>
        <tr><td></td><td id = "g41red_d"></td><td id = "g41blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g42num">42</td><td id = "g42red_u"></td><td id = "g42blue_u"></td><td></td></tr>
        <tr><td id = "g42red_l"></td><td id = "g42red_con"></td><td id = "g42reac"></td><td id = "g42red_r"></td></tr>
        <tr><td id = "g42blue_l"></td><td></td><td id = "g42blue_con"></td><td id = "g42blue_r"></td></tr>
        <tr><td></td><td id = "g42red_d"></td><td id = "g42blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g43num">43</td><td id = "g43red_u"></td><td id = "g43blue_u"></td><td></td></tr>
        <tr><td id = "g43red_l"></td><td id = "g43red_con"></td><td id = "g43reac"></td><td id = "g43red_r"></td></tr>
        <tr><td id = "g43blue_l"></td><td></td><td id = "g43blue_con"></td><td id = "g43blue_r"></td></tr>
        <tr><td></td><td id = "g43red_d"></td><td id = "g43blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g44num">44</td><td id = "g44red_u"></td><td id = "g44blue_u"></td><td></td></tr>
        <tr><td id = "g44red_l"></td><td id = "g44red_con"></td><td id = "g44reac"></td><td id = "g44red_r"></td></tr>
        <tr><td id = "g44blue_l"></td><td></td><td id = "g44blue_con"></td><td id = "g44blue_r"></td></tr>
        <tr><td></td><td id = "g44red_d"></td><td id = "g44blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g45num">45</td><td id = "g45red_u"></td><td id = "g45blue_u"></td><td></td></tr>
        <tr><td id = "g45red_l"></td><td id = "g45red_con"></td><td id = "g45reac"></td><td id = "g45red_r"></td></tr>
        <tr><td id = "g45blue_l"></td><td></td><td id = "g45blue_con"></td><td id = "g45blue_r"></td></tr>
        <tr><td></td><td id = "g45red_d"></td><td id = "g45blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g46num">46</td><td id = "g46red_u"></td><td id = "g46blue_u"></td><td></td></tr>
        <tr><td id = "g46red_l"></td><td id = "g46red_con"></td><td id = "g46reac"></td><td id = "g46red_r"></td></tr>
        <tr><td id = "g46blue_l"></td><td></td><td id = "g46blue_con"></td><td id = "g46blue_r"></td></tr>
        <tr><td></td><td id = "g46red_d"></td><td id = "g46blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g47num">47</td><td id = "g47red_u"></td><td id = "g47blue_u"></td><td></td></tr>
        <tr><td id = "g47red_l"></td><td id = "g47red_con"></td><td id = "g47reac"></td><td id = "g47red_r"></td></tr>
        <tr><td id = "g47blue_l"></td><td></td><td id = "g47blue_con"></td><td id = "g47blue_r"></td></tr>
        <tr><td></td><td id = "g47red_d"></td><td id = "g47blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g48num">48</td><td id = "g48red_u"></td><td id = "g48blue_u"></td><td></td></tr>
        <tr><td id = "g48red_l"></td><td id = "g48red_con"></td><td id = "g48reac"></td><td id = "g48red_r"></td></tr>
        <tr><td id = "g48blue_l"></td><td></td><td id = "g48blue_con"></td><td id = "g48blue_r"></td></tr>
        <tr><td></td><td id = "g48red_d"></td><td id = "g48blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g49num">49</td><td id = "g49red_u"></td><td id = "g49blue_u"></td><td></td></tr>
        <tr><td id = "g49red_l"></td><td id = "g49red_con"></td><td id = "g49reac"></td><td id = "g49red_r"></td></tr>
        <tr><td id = "g49blue_l"></td><td></td><td id = "g49blue_con"></td><td id = "g49blue_r"></td></tr>
        <tr><td></td><td id = "g49red_d"></td><td id = "g49blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g50num">50</td><td id = "g50red_u"></td><td id = "g50blue_u"></td><td></td></tr>
        <tr><td id = "g50red_l"></td><td id = "g50red_con"></td><td id = "g50reac"></td><td id = "g50red_r"></td></tr>
        <tr><td id = "g50blue_l"></td><td></td><td id = "g50blue_con"></td><td id = "g50blue_r"></td></tr>
        <tr><td></td><td id = "g50red_d"></td><td id = "g50blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g51num">51</td><td id = "g51red_u"></td><td id = "g51blue_u"></td><td></td></tr>
        <tr><td id = "g51red_l"></td><td id = "g51red_con"></td><td id = "g51reac"></td><td id = "g51red_r"></td></tr>
        <tr><td id = "g51blue_l"></td><td></td><td id = "g51blue_con"></td><td id = "g51blue_r"></td></tr>
        <tr><td></td><td id = "g51red_d"></td><td id = "g51blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g52num">52</td><td id = "g52red_u"></td><td id = "g52blue_u"></td><td></td></tr>
        <tr><td id = "g52red_l"></td><td id = "g52red_con"></td><td id = "g52reac"></td><td id = "g52red_r"></td></tr>
        <tr><td id = "g52blue_l"></td><td></td><td id = "g52blue_con"></td><td id = "g52blue_r"></td></tr>
        <tr><td></td><td id = "g52red_d"></td><td id = "g52blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g53num">53</td><td id = "g53red_u"></td><td id = "g53blue_u"></td><td></td></tr>
        <tr><td id = "g53red_l"></td><td id = "g53red_con"></td><td id = "g53reac"></td><td id = "g53red_r"></td></tr>
        <tr><td id = "g53blue_l"></td><td></td><td id = "g53blue_con"></td><td id = "g53blue_r"></td></tr>
        <tr><td></td><td id = "g53red_d"></td><td id = "g53blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g54num">54</td><td id = "g54red_u"></td><td id = "g54blue_u"></td><td></td></tr>
        <tr><td id = "g54red_l"></td><td id = "g54red_con"></td><td id = "g54reac"></td><td id = "g54red_r"></td></tr>
        <tr><td id = "g54blue_l"></td><td></td><td id = "g54blue_con"></td><td id = "g54blue_r"></td></tr>
        <tr><td></td><td id = "g54red_d"></td><td id = "g54blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g55num">55</td><td id = "g55red_u"></td><td id = "g55blue_u"></td><td></td></tr>
        <tr><td id = "g55red_l"></td><td id = "g55red_con"></td><td id = "g55reac"></td><td id = "g55red_r"></td></tr>
        <tr><td id = "g55blue_l"></td><td></td><td id = "g55blue_con"></td><td id = "g55blue_r"></td></tr>
        <tr><td></td><td id = "g55red_d"></td><td id = "g55blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g56num">56</td><td id = "g56red_u"></td><td id = "g56blue_u"></td><td></td></tr>
        <tr><td id = "g56red_l"></td><td id = "g56red_con"></td><td id = "g56reac"></td><td id = "g56red_r"></td></tr>
        <tr><td id = "g56blue_l"></td><td></td><td id = "g56blue_con"></td><td id = "g56blue_r"></td></tr>
        <tr><td></td><td id = "g56red_d"></td><td id = "g56blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g57num">57</td><td id = "g57red_u"></td><td id = "g57blue_u"></td><td></td></tr>
        <tr><td id = "g57red_l"></td><td id = "g57red_con"></td><td id = "g57reac"></td><td id = "g57red_r"></td></tr>
        <tr><td id = "g57blue_l"></td><td></td><td id = "g57blue_con"></td><td id = "g57blue_r"></td></tr>
        <tr><td></td><td id = "g57red_d"></td><td id = "g57blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g58num">58</td><td id = "g58red_u"></td><td id = "g58blue_u"></td><td></td></tr>
        <tr><td id = "g58red_l"></td><td id = "g58red_con"></td><td id = "g58reac"></td><td id = "g58red_r"></td></tr>
        <tr><td id = "g58blue_l"></td><td></td><td id = "g58blue_con"></td><td id = "g58blue_r"></td></tr>
        <tr><td></td><td id = "g58red_d"></td><td id = "g58blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g59num">59</td><td id = "g59red_u"></td><td id = "g59blue_u"></td><td></td></tr>
        <tr><td id = "g59red_l"></td><td id = "g59red_con"></td><td id = "g59reac"></td><td id = "g59red_r"></td></tr>
        <tr><td id = "g59blue_l"></td><td></td><td id = "g59blue_con"></td><td id = "g59blue_r"></td></tr>
        <tr><td></td><td id = "g59red_d"></td><td id = "g59blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g60num">60</td><td id = "g60red_u"></td><td id = "g60blue_u"></td><td></td></tr>
        <tr><td id = "g60red_l"></td><td id = "g60red_con"></td><td id = "g60reac"></td><td id = "g60red_r"></td></tr>
        <tr><td id = "g60blue_l"></td><td></td><td id = "g60blue_con"></td><td id = "g60blue_r"></td></tr>
        <tr><td></td><td id = "g60red_d"></td><td id = "g60blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g61num">61</td><td id = "g61red_u"></td><td id = "g61blue_u"></td><td></td></tr>
        <tr><td id = "g61red_l"></td><td id = "g61red_con"></td><td id = "g61reac"></td><td id = "g61red_r"></td></tr>
        <tr><td id = "g61blue_l"></td><td></td><td id = "g61blue_con"></td><td id = "g61blue_r"></td></tr>
        <tr><td></td><td id = "g61red_d"></td><td id = "g61blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g62num">62</td><td id = "g62red_u"></td><td id = "g62blue_u"></td><td></td></tr>
        <tr><td id = "g62red_l"></td><td id = "g62red_con"></td><td id = "g62reac"></td><td id = "g62red_r"></td></tr>
        <tr><td id = "g62blue_l"></td><td></td><td id = "g62blue_con"></td><td id = "g62blue_r"></td></tr>
        <tr><td></td><td id = "g62red_d"></td><td id = "g62blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g63num">63</td><td id = "g63red_u"></td><td id = "g63blue_u"></td><td></td></tr>
        <tr><td id = "g63red_l"></td><td id = "g63red_con"></td><td id = "g63reac"></td><td id = "g63red_r"></td></tr>
        <tr><td id = "g63blue_l"></td><td></td><td id = "g63blue_con"></td><td id = "g63blue_r"></td></tr>
        <tr><td></td><td id = "g63red_d"></td><td id = "g63blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g64num">64</td><td id = "g64red_u"></td><td id = "g64blue_u"></td><td></td></tr>
        <tr><td id = "g64red_l"></td><td id = "g64red_con"></td><td id = "g64reac"></td><td id = "g64red_r"></td></tr>
        <tr><td id = "g64blue_l"></td><td></td><td id = "g64blue_con"></td><td id = "g64blue_r"></td></tr>
        <tr><td></td><td id = "g64red_d"></td><td id = "g64blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g65num">65</td><td id = "g65red_u"></td><td id = "g65blue_u"></td><td></td></tr>
        <tr><td id = "g65red_l"></td><td id = "g65red_con"></td><td id = "g65reac"></td><td id = "g65red_r"></td></tr>
        <tr><td id = "g65blue_l"></td><td></td><td id = "g65blue_con"></td><td id = "g65blue_r"></td></tr>
        <tr><td></td><td id = "g65red_d"></td><td id = "g65blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g66num">66</td><td id = "g66red_u"></td><td id = "g66blue_u"></td><td></td></tr>
        <tr><td id = "g66red_l"></td><td id = "g66red_con"></td><td id = "g66reac"></td><td id = "g66red_r"></td></tr>
        <tr><td id = "g66blue_l"></td><td></td><td id = "g66blue_con"></td><td id = "g66blue_r"></td></tr>
        <tr><td></td><td id = "g66red_d"></td><td id = "g66blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g67num">67</td><td id = "g67red_u"></td><td id = "g67blue_u"></td><td></td></tr>
        <tr><td id = "g67red_l"></td><td id = "g67red_con"></td><td id = "g67reac"></td><td id = "g67red_r"></td></tr>
        <tr><td id = "g67blue_l"></td><td></td><td id = "g67blue_con"></td><td id = "g67blue_r"></td></tr>
        <tr><td></td><td id = "g67red_d"></td><td id = "g67blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g68num">68</td><td id = "g68red_u"></td><td id = "g68blue_u"></td><td></td></tr>
        <tr><td id = "g68red_l"></td><td id = "g68red_con"></td><td id = "g68reac"></td><td id = "g68red_r"></td></tr>
        <tr><td id = "g68blue_l"></td><td></td><td id = "g68blue_con"></td><td id = "g68blue_r"></td></tr>
        <tr><td></td><td id = "g68red_d"></td><td id = "g68blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g69num">69</td><td id = "g69red_u"></td><td id = "g69blue_u"></td><td></td></tr>
        <tr><td id = "g69red_l"></td><td id = "g69red_con"></td><td id = "g69reac"></td><td id = "g69red_r"></td></tr>
        <tr><td id = "g69blue_l"></td><td></td><td id = "g69blue_con"></td><td id = "g69blue_r"></td></tr>
        <tr><td></td><td id = "g69red_d"></td><td id = "g69blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g70num">70</td><td id = "g70red_u"></td><td id = "g70blue_u"></td><td></td></tr>
        <tr><td id = "g70red_l"></td><td id = "g70red_con"></td><td id = "g70reac"></td><td id = "g70red_r"></td></tr>
        <tr><td id = "g70blue_l"></td><td></td><td id = "g70blue_con"></td><td id = "g70blue_r"></td></tr>
        <tr><td></td><td id = "g70red_d"></td><td id = "g70blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>

  <tr>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g71num">71</td><td id = "g71red_u"></td><td id = "g71blue_u"></td><td></td></tr>
        <tr><td id = "g71red_l"></td><td id = "g71red_con"></td><td id = "g71reac"></td><td id = "g71red_r"></td></tr>
        <tr><td id = "g71blue_l"></td><td></td><td id = "g71blue_con"></td><td id = "g71blue_r"></td></tr>
        <tr><td></td><td id = "g71red_d"></td><td id = "g71blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g72num">72</td><td id = "g72red_u"></td><td id = "g72blue_u"></td><td></td></tr>
        <tr><td id = "g72red_l"></td><td id = "g72red_con"></td><td id = "g72reac"></td><td id = "g72red_r"></td></tr>
        <tr><td id = "g72blue_l"></td><td></td><td id = "g72blue_con"></td><td id = "g72blue_r"></td></tr>
        <tr><td></td><td id = "g72red_d"></td><td id = "g72blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g73num">73</td><td id = "g73red_u"></td><td id = "g73blue_u"></td><td></td></tr>
        <tr><td id = "g73red_l"></td><td id = "g73red_con"></td><td id = "g73reac"></td><td id = "g73red_r"></td></tr>
        <tr><td id = "g73blue_l"></td><td></td><td id = "g73blue_con"></td><td id = "g73blue_r"></td></tr>
        <tr><td></td><td id = "g73red_d"></td><td id = "g73blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#a0a0a0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g74num">74</td><td id = "g74red_u"></td><td id = "g74blue_u"></td><td></td></tr>
        <tr><td id = "g74red_l"></td><td id = "g74red_con"></td><td id = "g74reac"></td><td id = "g74red_r"></td></tr>
        <tr><td id = "g74blue_l"></td><td></td><td id = "g74blue_con"></td><td id = "g74blue_r"></td></tr>
        <tr><td></td><td id = "g74red_d"></td><td id = "g74blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g75num">75</td><td id = "g75red_u"></td><td id = "g75blue_u"></td><td></td></tr>
        <tr><td id = "g75red_l"></td><td id = "g75red_con"></td><td id = "g75reac"></td><td id = "g75red_r"></td></tr>
        <tr><td id = "g75blue_l"></td><td></td><td id = "g75blue_con"></td><td id = "g75blue_r"></td></tr>
        <tr><td></td><td id = "g75red_d"></td><td id = "g75blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#808080">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g76num">76</td><td id = "g76red_u"></td><td id = "g76blue_u"></td><td></td></tr>
        <tr><td id = "g76red_l"></td><td id = "g76red_con"></td><td id = "g76reac"></td><td id = "g76red_r"></td></tr>
        <tr><td id = "g76blue_l"></td><td></td><td id = "g76blue_con"></td><td id = "g76blue_r"></td></tr>
        <tr><td></td><td id = "g76red_d"></td><td id = "g76blue_d"></td><td></td></tr>
      </tbody></table>
    </td>

    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g77num">77</td><td id = "g77red_u"></td><td id = "g77blue_u"></td><td></td></tr>
        <tr><td id = "g77red_l"></td><td id = "g77red_con"></td><td id = "g77reac"></td><td id = "g77red_r"></td></tr>
        <tr><td id = "g77blue_l"></td><td></td><td id = "g77blue_con"></td><td id = "g77blue_r"></td></tr>
        <tr><td></td><td id = "g77red_d"></td><td id = "g77blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g78num">78</td><td id = "g78red_u"></td><td id = "g78blue_u"></td><td></td></tr>
        <tr><td id = "g78red_l"></td><td id = "g78red_con"></td><td id = "g78reac"></td><td id = "g78red_r"></td></tr>
        <tr><td id = "g78blue_l"></td><td></td><td id = "g78blue_con"></td><td id = "g78blue_r"></td></tr>
        <tr><td></td><td id = "g78red_d"></td><td id = "g78blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g79num">79</td><td id = "g79red_u"></td><td id = "g79blue_u"></td><td></td></tr>
        <tr><td id = "g79red_l"></td><td id = "g79red_con"></td><td id = "g79reac"></td><td id = "g79red_r"></td></tr>
        <tr><td id = "g79blue_l"></td><td></td><td id = "g79blue_con"></td><td id = "g79blue_r"></td></tr>
        <tr><td></td><td id = "g79red_d"></td><td id = "g79blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
    <td style = "background-color:#c0c0c0">
      <table border = 0 cellpadding = 2 cellspacing = 0><tbody>
        <tr><td id = "g80num">80</td><td id = "g80red_u"></td><td id = "g80blue_u"></td><td></td></tr>
        <tr><td id = "g80red_l"></td><td id = "g80red_con"></td><td id = "g80reac"></td><td id = "g80red_r"></td></tr>
        <tr><td id = "g80blue_l"></td><td></td><td id = "g80blue_con"></td><td id = "g80blue_r"></td></tr>
        <tr><td></td><td id = "g80red_d"></td><td id = "g80blue_d"></td><td></td></tr>
      </tbody></table>
    </td>
  </tr>
</tbody>
</table>
</div>

<br><br>

<div>
Add or change something on the grid:<br>
<table border = 0 cellpadding = 5 cellspacing = 2 style = "text-align:left"><tbody>
  <tr>
    <td style = "vertical-align:top">
      Grid position:<br>
      <input type = "number" id = "input_grid_number" min = "1" max = "80" step = "1" value = "1" onchange = "number_prettifier()">
    </td>
    <td style = "vertical-align:top">
      Object type:<br>
      <select id = "grid_object_select">
        <optgroup label = "Reactor Devices">
          <option>Bonder</option>
          <option>Atom Sensor</option>
          <option>Fusion Target</option>
          <option>Fission Target</option>
          <option>Quantum Tunnel</option>
        </optgroup>
        <optgroup label = "Reaction Controls">
          <option>Start</option>
          <option>Waldo Direction</option>
          <option>Bond +</option>
          <option>Bond -</option>
          <option>Grab/Drop</option>
          <option>Grab</option>
          <option>Drop</option>
          <option>In Alpha</option>
          <option>In Beta</option>
          <option>Out Psi</option>
          <option>Out Omega</option>
          <option>Sync</option>
          <option>Rotate Clockwise</option>
          <option>Rotate Counterclockwise</option>
          <option>Sensor Redirect</option>
          <option>Fuse</option>
          <option>Split</option>
          <option>Flip Flop</option>
          <option>Swap (activate quantum tunnel)</option>
        </optgroup>
      </select>
    </td>
    <td style = "vertical-align:top">
      Color:<br>
      <select id = "color_select">
        <option>Red</option>
        <option>Blue</option>
      </select>
    </td>
    <td style = "vertical-align:top">
      Direction:<br>
      <select id = "direction_select">
        <option>Up</option>
        <option>Left</option>
        <option>Right</option>
        <option>Down</option>
      </select>
    </td>
    <td style = "vertical-align:top">
      Atom (for sensor redirects):<br>
      <select id = "input_atom_select" class = "atom_select"></select>
    </td>
    <td style = "vertical-align:top">
      Putting it there or taking it back out?<br>
      <button id = "input_add" onclick = "grid_button_handler(this)">Add</button>
      <button id = "input_remove" onclick = "grid_button_handler(this)">Remove</button>
    </td>
    <td style = "vertical-align:top">
      <div>
        Clear the grid and start over:<br>
        <button id = "clear_grid_prelim_button" onclick = "grid_button_handler(this)">Clear Grid</button>
      </div>
      <div id = "clear_confirm_div" hidden>
        <br>
        Really clear the grid?<br>
        <button style = "border-color:red" id = "clear_grid_button" onclick = "grid_button_handler(this)">YES</button> <button id = "clear_grid_no" onclick = "grid_button_handler(this)">No</button>
      </div>
    </td>
  </tr>
</tbody></table>
<br><br>
Some notes:
<ul>
  <li>Settings irrelevant to particular devices are ignored.  For instance, it does not matter how "Direction" is set when placing "Grab" controls.</li>
  <li>Fusion and fission targets take up two side-by-side grid spaces.  When placing a target, these controls refer to the left side of those devices.  As such, that left side cannot be placed in the rightmost column.</li>
  <li>There must be exactly 0 or 2 quantum tunnels in your solution.</li>
</ul>
</div>

<hr>

<div>
<b>Section 2:</b> Set input molecules and add input and output labels in this section.  You must have at least one input molecule, and an input sequence that includes that molecule, or the reaction will not run.<br><br>

First of all, select whether your reactor has standard outputs &#968; and &#969; or single large output &#968;:<br>
<select id = "big_psi_select">
  <option>Standard &#968; and &#969;</option>
  <option>Large &#968;</option>
</select>
<br><br>

<!-- atom, bond, atom... 
    bond, blank, bond... -->

Now, use this thing below to draw a molecule.  Select atoms with the drop-down menus and indicate bond strength with the checkboxes.  <u>Use the white areas only</u>, unless you are drawing a label for large output &#968;.<br>
<table border = "1" cellpadding = "1" cellspacing = "0"><tbody>
  <tr>
    <td><select id = "l1_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l1l2bond"><br><input type = "checkbox" class = "l1l2bond"><br><input type = "checkbox" class = "l1l2bond"></td>
    <td><select id = "l2_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l2l3bond"><br><input type = "checkbox" class = "l2l3bond"><br><input type = "checkbox" class = "l2l3bond"></td>
    <td><select id = "l3_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l3l4bond"><br><input type = "checkbox" class = "l3l4bond"><br><input type = "checkbox" class = "l3l4bond"></td>
    <td><select id = "l4_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr>
    <td><input type = "checkbox" class = "l1l5bond"><input type = "checkbox" class = "l1l5bond"><input type = "checkbox" class = "l1l5bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l2l6bond"><input type = "checkbox" class = "l2l6bond"><input type = "checkbox" class = "l2l6bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l3l7bond"><input type = "checkbox" class = "l3l7bond"><input type = "checkbox" class = "l3l7bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l4l8bond"><input type = "checkbox" class = "l4l8bond"><input type = "checkbox" class = "l4l8bond"></td>
  </tr>
  <tr>
    <td><select id = "l5_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l5l6bond"><br><input type = "checkbox" class = "l5l6bond"><br><input type = "checkbox" class = "l5l6bond"></td>
    <td><select id = "l6_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l6l7bond"><br><input type = "checkbox" class = "l6l7bond"><br><input type = "checkbox" class = "l6l7bond"></td>
    <td><select id = "l7_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l7l8bond"><br><input type = "checkbox" class = "l7l8bond"><br><input type = "checkbox" class = "l7l8bond"></td>
    <td><select id = "l8_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr>
    <td><input type = "checkbox" class = "l5l9bond"><input type = "checkbox" class = "l5l9bond"><input type = "checkbox" class = "l5l9bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l6l10bond"><input type = "checkbox" class = "l6l10bond"><input type = "checkbox" class = "l6l10bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l7l11bond"><input type = "checkbox" class = "l7l11bond"><input type = "checkbox" class = "l7l11bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l8l12bond"><input type = "checkbox" class = "l8l12bond"><input type = "checkbox" class = "l8l12bond"></td>
  </tr>
  <tr>
    <td><select id = "l9_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l9l10bond"><br><input type = "checkbox" class = "l9l10bond"><br><input type = "checkbox" class = "l9l10bond"></td>
    <td><select id = "l10_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l10l11bond"><br><input type = "checkbox" class = "l10l11bond"><br><input type = "checkbox" class = "l10l11bond"></td>
    <td><select id = "l11_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l11l12bond"><br><input type = "checkbox" class = "l11l12bond"><br><input type = "checkbox" class = "l11l12bond"></td>
    <td><select id = "l12_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr>
    <td><input type = "checkbox" class = "l9l13bond"><input type = "checkbox" class = "l9l13bond"><input type = "checkbox" class = "l9l13bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l10l14bond"><input type = "checkbox" class = "l10l14bond"><input type = "checkbox" class = "l10l14bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l11l15bond"><input type = "checkbox" class = "l11l15bond"><input type = "checkbox" class = "l11l15bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l12l16bond"><input type = "checkbox" class = "l12l16bond"><input type = "checkbox" class = "l12l16bond"></td>
  </tr>
  <tr>
    <td><select id = "l13_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l13l14bond"><br><input type = "checkbox" class = "l13l14bond"><br><input type = "checkbox" class = "l13l14bond"></td>
    <td><select id = "l14_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l14l15bond"><br><input type = "checkbox" class = "l14l15bond"><br><input type = "checkbox" class = "l14l15bond"></td>
    <td><select id = "l15_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l15l16bond"><br><input type = "checkbox" class = "l15l16bond"><br><input type = "checkbox" class = "l15l16bond"></td>
    <td><select id = "l16_atom_select" class = "atom_select"></select></td>
  </tr>

  <tr style = "background-color:#c0c0c0">
    <td><input type = "checkbox" class = "l13l17bond"><input type = "checkbox" class = "l13l17bond"><input type = "checkbox" class = "l13l17bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l14l18bond"><input type = "checkbox" class = "l14l18bond"><input type = "checkbox" class = "l14l18bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l15l19bond"><input type = "checkbox" class = "l15l19bond"><input type = "checkbox" class = "l15l19bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l16l20bond"><input type = "checkbox" class = "l16l20bond"><input type = "checkbox" class = "l16l20bond"></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><select id = "l17_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l17l18bond"><br><input type = "checkbox" class = "l17l18bond"><br><input type = "checkbox" class = "l17l18bond"></td>
    <td><select id = "l18_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l18l19bond"><br><input type = "checkbox" class = "l18l19bond"><br><input type = "checkbox" class = "l18l19bond"></td>
    <td><select id = "l19_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l19l20bond"><br><input type = "checkbox" class = "l19l20bond"><br><input type = "checkbox" class = "l19l20bond"></td>
    <td><select id = "l20_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><input type = "checkbox" class = "l17l21bond"><input type = "checkbox" class = "l17l21bond"><input type = "checkbox" class = "l17l21bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l18l22bond"><input type = "checkbox" class = "l18l22bond"><input type = "checkbox" class = "l18l22bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l19l23bond"><input type = "checkbox" class = "l19l23bond"><input type = "checkbox" class = "l19l23bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l20l24bond"><input type = "checkbox" class = "l20l24bond"><input type = "checkbox" class = "l20l24bond"></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><select id = "l21_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l21l22bond"><br><input type = "checkbox" class = "l21l22bond"><br><input type = "checkbox" class = "l21l22bond"></td>
    <td><select id = "l22_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l22l23bond"><br><input type = "checkbox" class = "l22l23bond"><br><input type = "checkbox" class = "l22l23bond"></td>
    <td><select id = "l23_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l23l24bond"><br><input type = "checkbox" class = "l23l24bond"><br><input type = "checkbox" class = "l23l24bond"></td>
    <td><select id = "l24_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><input type = "checkbox" class = "l21l25bond"><input type = "checkbox" class = "l21l25bond"><input type = "checkbox" class = "l21l25bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l22l26bond"><input type = "checkbox" class = "l22l26bond"><input type = "checkbox" class = "l22l26bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l23l27bond"><input type = "checkbox" class = "l23l27bond"><input type = "checkbox" class = "l23l27bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l24l28bond"><input type = "checkbox" class = "l24l28bond"><input type = "checkbox" class = "l24l28bond"></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><select id = "l25_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l25l26bond"><br><input type = "checkbox" class = "l25l26bond"><br><input type = "checkbox" class = "l25l26bond"></td>
    <td><select id = "l26_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l26l27bond"><br><input type = "checkbox" class = "l26l27bond"><br><input type = "checkbox" class = "l26l27bond"></td>
    <td><select id = "l27_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l27l28bond"><br><input type = "checkbox" class = "l27l28bond"><br><input type = "checkbox" class = "l27l28bond"></td>
    <td><select id = "l28_atom_select" class = "atom_select"></select></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><input type = "checkbox" class = "l25l29bond"><input type = "checkbox" class = "l25l29bond"><input type = "checkbox" class = "l25l29bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l26l30bond"><input type = "checkbox" class = "l26l30bond"><input type = "checkbox" class = "l26l30bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l27l31bond"><input type = "checkbox" class = "l27l31bond"><input type = "checkbox" class = "l27l31bond"></td>
    <td></td>
    <td><input type = "checkbox" class = "l28l32bond"><input type = "checkbox" class = "l28l32bond"><input type = "checkbox" class = "l28l32bond"></td>
  </tr>
  <tr style = "background-color:#c0c0c0">
    <td><select id = "l29_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l29l30bond"><br><input type = "checkbox" class = "l29l30bond"><br><input type = "checkbox" class = "l29l30bond"></td>
    <td><select id = "l30_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l30l31bond"><br><input type = "checkbox" class = "l30l31bond"><br><input type = "checkbox" class = "l30l31bond"></td>
    <td><select id = "l31_atom_select" class = "atom_select"></select></td>
    <td><input type = "checkbox" class = "l31l32bond"><br><input type = "checkbox" class = "l31l32bond"><br><input type = "checkbox" class = "l31l32bond"></td>
    <td><select id = "l32_atom_select" class = "atom_select"></select></td>
  </tr>
</tbody></table>
<br>
<button id = "clear_molecule_draw" onclick = "molecule_draw_clear_function()">Clear the molecule drawing tool</button>
</div>

<div>
<br><br>

Now here's what you can do with that molecule:
<br><br>

<table border = 0 cellpadding = 5 cellspacing = 2 style = "text-align:left"><tbody>
  <tr>
    <td style = "vertical-align:top">
      <button id = "set_a1" onclick = "set_a1_fn()">Set as molecule A1</button>&nbsp;<span id = "a1_span"></span><br>
      <button id = "set_a2" onclick = "set_a2_fn()">Set as molecule A2</button>&nbsp;<span id = "a2_span"></span><br>
      <button id = "set_a3" onclick = "set_a3_fn()">Set as molecule A3</button>&nbsp;<span id = "a3_span"></span><br><br>
      <button id = "add_a1" onclick = "add_fn(this)">Add an A1 to &#945; input sequence</button><br>
      <button id = "add_a2" onclick = "add_fn(this)">Add an A2 to &#945; input sequence</button><br>
      <button id = "add_a3" onclick = "add_fn(this)">Add an A3 to &#945; input sequence</button><br><br>
      Current &#945; input sequence:<br>
      <textarea id = "alpha_sequence" readonly cols = "20" rows = "2"></textarea><br>
      <button id = "alpha_backspace" onclick = "alpha_pop()">Remove last &#945; symbol</button>
      <br><br>
      <button id = "clear_alpha_sequence" onclick = "clear_alpha_seq_fn()">Clear &#945; sequence</button><br>
      <button id = "clear_alpha_molecules" onclick = "clear_alpha_mol_fn()">Clear &#945; molecules</button>
      <!-- <button id = "clear_alpha" onclick = "clear_alpha_fn()">Clear &#945; sequence and molecules</button> -->
    </td>
    <td style = "vertical-align:top">
      <button id = "set_b1" onclick = "set_b1_fn()">Set as molecule B1</button>&nbsp;<span id = "b1_span"></span><br>
      <button id = "set_b2" onclick = "set_b2_fn()">Set as molecule B2</button>&nbsp;<span id = "b2_span"></span><br>
      <button id = "set_b3" onclick = "set_b3_fn()">Set as molecule B3</button>&nbsp;<span id = "b3_span"></span><br><br>
      <button id = "add_b1" onclick = "add_fn(this)">Add a B1 to &#946; input sequence</button><br>
      <button id = "add_b2" onclick = "add_fn(this)">Add a B2 to &#946; input sequence</button><br>
      <button id = "add_b3" onclick = "add_fn(this)">Add a B3 to &#946; input sequence</button><br><br>
      Current &#946; input sequence:<br>
      <textarea id = "beta_sequence" readonly cols = "20" rows = "2"></textarea><br>
      <button id = "beta_backspace" onclick = "beta_pop()">Remove last &#946; symbol</button>
      <br><br>
      <button id = "clear_beta_sequence" onclick = "clear_beta_seq_fn()">Clear &#946; sequence</button><br>
      <button id = "clear_beta_molecules" onclick = "clear_beta_mol_fn()">Clear &#946; molecules</button>
      <!-- <button id = "clear_beta" onclick = "clear_beta_fn()">Clear &#946; sequence and molecules</button> -->
    </td>
    <td style = "vertical-align:top">
      <button id = "set_psi_label" onclick = "set_psi_label_fn()">Set as label for output &#968;</button><br>
      <span id = "psi_label_span"></span>
    </td>
    <td style = "vertical-align:top">
      <button id = "set_omega_label" onclick = "set_omega_label_fn()">Set as label for output &#969;</button><br>
      <span id = "omega_label_span"></span>
    </td>
  </tr>
</tbody></table>
<br><br>
Some more notes:<br>
<ul>
  <li>Use only the upper white boxes unless you are creating a label for large output &#968;.  Any use of the lower gray boxes for anything other than large output &#968; will be rejected.</li>
  <li>As in Spacechem, a molecule's position in the label matches the position it will arrive in the input region.</li>
  <li>Each input can supply up to three molecule types.  These molecules will be shown as preview labels in the blank space beside the input areas.</li>
  <li>The input sequences describe the order in which the molecules assigned as A1-A3 and B1-B3 will arrive at their respective inputs.
    <ul>
      <li>If the end of an input sequence is reached, the sequence repeats from the beginning.</li>
      <li>If an input only sends in a single type of molecule, a single molecule type symbol is sufficient for the entire input sequence (i.e. all that would be needed for the input sequence could be just "A1").</li>
      <li>Input sequences can be arbitrarily long.</li>
      <li>If Spacechem sends your in-game solution different molecules in random order, pay close attention to the ordering you end up getting and replicate it here.  (Or mix it up; a well-built solution should be able to handle that, right?)</li>
    </ul>
  </li>
  <li>Each output can display a single molecule as a preview label in the blank space beside the output area.</li>
  <li>Output labels are not enforced.  Each output takes any molecule that fits when its output control is called.  Output labels are strictly for decoration and reminder of what the solution is supposed to be doing.</li>
  <li>Creating a molecule in which an atom has more bonds than it can usually make will produce a warning, but is not strictly prohibited since such molecules do work in Spacechem.</li>
</ul>
</div>

<hr>

<div>
<b>Section 3:</b> And here's where you can get the results of all that.<br><br>

Generate a preview scene to make sure all your reactor parts are in the right place (this will be a single, static image showing the reactor state before reactions begin):<br><br>

<button id = "generate_preview" onclick = "generate_preview_fn()">Generate Preview</button><br><br>

Your preview .ini file is here:<br>
(Note: the preview .ini file will be the same one every time; you won't need to save a new one for every different preview.)<br>
<textarea id = "preview_ini_output" cols="80" rows="15" readonly></textarea>
<button id = "select_preview_ini" onclick = "select_preview_ini_fn()">Select preview .ini text</button>
<br><br>

And your preview scene file (.pov) is here:<br>
<textarea id = "preview_scene_output" cols="80" rows="15" readonly></textarea>
<button id = "select_preview_scene" onclick = "select_preview_scene_fn()">Select preview scene text</button>
<br><br>

Save them both somewhere, open the scene file in POV-Ray, choose a resolution in the top-left, click the "Ini" button along the top, and choose that .ini file you just made.  Render it and compare the resulting image with what you expected to get.  (Don't forget <a href = "povchem.inc" target = "_blank">the include file</a>!)
<br><br>

OR...<br><br>

Simulate the reaction and generate the real, animated, thing-you-came-here-for scene:<br><br>

<ul>
<li>Run until... <select id = "how_long_to_run">
  <option>this many molecules have been delivered to output &#968;:</option>
  <option>this many molecules have been delivered to output &#969;:</option>
  <option>this many cycles have passed:</option>
</select> <input type = "number" id = "input_reaction_limit" min = "1" max = "10000" step = "1" value = "4">
(optional: ... and for this many cycles beyond that: <input type = "number" id = "input_reaction_extra_cycles" min = "0" max = "100" step = "1" value = "0">)<br>
(Note that I've put in a hard limit of 10,000 cycles to keep things somewhat reasonable.)<br><br></li>

<li>Frames per cycle: <input type = "number" id = "input_frames_per_cycle" min = "1" step = "1" value = "24"><br>
At this point you should think ahead to the video you're going to stitch together from the pile of sequential static images your scene is going to give you.  You should consider what sort of framerate you want and how long each cycle should last.  Then you should math those numbers together and get a number for the frames-per-cycle box above.
<br><br>
As a hopefully helpful reference for where to start, I usually make my videos at 60fps.  At that framerate, I find that 24 frames per cycle works well for shorter animations, while 18 frames per cycle can keep longer animations from dragging on too long and still keep clear what the reaction is doing.</li>
</ul>

<br><br>
<button style = "text-align:center" id = "for_real_button" onclick = "gray_and_go()">
DO IT!<br>
SIMULATE THE REACTION!<br>
GENERATE THE ANIMATED SCENE!</button><br><br>
Be sure to check the log output back at the top of the page for any warnings or errors, so that you don't spend several hours rendering a mistake.<br><br>

And finally, here's your actual .ini file:<br>
(Note: the actual .ini likely <b>will</b> be different each time, so be sure to save each new one.)<br>
<textarea id = "real_ini_output" cols="80" rows="15" readonly></textarea>
<button id = "select_real_ini" onclick = "select_real_ini_fn()">Select animated .ini text</button>
<br><br>

... and your actual scene file (.pov):<br>
<textarea id = "real_scene_output" cols="80" rows="15" readonly></textarea>
<button id = "select_real_scene" onclick = "select_real_scene_fn()">Select animated scene text</button><br><br>

Save them both somewhere, open the scene file in POV-Ray, click the "Ini" button along the top, and choose that .ini file you just made.  Select a resolution from the dropdown in the top-left, below the main toolbar, and then go find something else to do, because once you click "Render," your computer will be a bit busy.
<br><br>
You may want to try the "<span style = "font-family:Monospace">[Anim (test render) 640x360]</span>" resolution first.  This will produce a small and ugly animation of your solution, but it will produce it very quickly.  This way you can verify that your solution worked correctly before you invest a lot of time rendering the real thing.
</div>

<hr>

<div>
<b>Troubleshooting</b>
<br><br>

<b>My long render failed halfway through</b><br>
Yeah it might do that, perhaps a few thousand frames in.  This appears to be a problem with POV-Ray.  But all is not lost!  you can resume your render from the point it failed.  Here's how:
<ol>
  <li>Go to the directory where POV-Ray put its output images.</li>
  <li>Find the last image it produced and note the number at the end of it.</li>
  <li>Open your .ini file in your favorite text editor.  If you don't have a favorite, you can open it in POV-Ray by clicking the "Ini" button on the toolbar and then clicking the "Edit" button in the "Ini file:" section.</li>
  <li>Find the section for the resolution you chose.  This will be headed by one of the bracketed lines such as "<span style = "font-family:Monospace">[Anim 1920x1080]</span>".</li>
  <li>Find the line in that section that begins "<span style = "font-family:Monospace">Subset_Start_Frame=</span>".  If you haven't tried this method before, the number after that should be <span style = "font-family:Monospace">0</span>.</li>
  <li>Change that number to the number you noted above and save the file.</li>
  <li>Go to POV-Ray and start the render.  It will pick up from that point.</li>
  <li>Repeat as (hopefully minimally) necessary.</li>
</ol>
Of course, if you want to start over later, change that line back to "<span style = "font-family:Monospace">Subset_Start_Frame=0</span>".
<br><br>

<span id = "font_troubleshooting"></span><b>POV-Ray can't find "times.ttf"</b> or <b>Several characters are badly misaligned</b><br>
You may not have the Times New Roman font (times.ttf) or you may have a different version than I do.  Fortunately I have found a different suitable font from a free, reputable source:
<ol>
  <li>Go to <a href = "https://fonts.google.com" target = "_blank">Google Fonts</a> and find the font "<a href = "https://fonts.google.com/specimen/Noto+Serif" target = "_blank">Noto Serif</a>."</li>
  <li>Click "Select this font" at the top-right.</li>
  <li>Click the "1 Family Selected" tab that pops up at the bottom of the screen.</li>
  <li>Download the font.  The download button is at the top-right of the box that expands from that tab.</li>
  <li>Unpack that .zip file; read and decide whether to agree to the license terms, as you surely do for all licenses.</li>
  <li>Assuming you agreed, copy the file "NotoSerif-Regular.ttf" to somewhere POV-Ray can find it, for instance to the same directory as the include or scene files.</li>
  <li>Open the include file (povchem.inc) in your favorite text editor and find the line that reads "<span style = "font-family:Monospace">#declare use_Noto = 0;</span>"</li>
  <li>Change that to "<span style = "font-family:Monospace">#declare use_Noto = 1;</span>" and save the file.
</ol>
Your render should now proceed correctly.  Or at least it should no longer have that problem.
</div>

<hr>

<div id = "gallery">
<b>The Gallery</b>
<br><br>
<iframe width="640" height="360" src="https://www.youtube.com/embed/SUF3Po-9U48" frameborder="0" allowfullscreen></iframe><br>
<b>PovChem Walkthrough:</b> a tutorial showing how to make an example scene
<br><br>
<iframe width="640" height="360" src="https://www.youtube.com/embed/oaxPhq0ltpU" frameborder="0" allowfullscreen></iframe><br>
<b>Delta-Pseudopolyethylene 2834:</b> A somewhat inefficient solution to the "Suspicious Behavior" assignment (spoilers!) but one that makes for a good showcase of what PovChem can do.
<br><br>
<a href = "periodic_atom_test.png" target = "_blank"><img border = "0" width = "640" height = "360" src = "periodic_atom_test.png"></a><br>
All the PovChem elements lined up posing for a photograph in front of the reactor grid.  They didn't quite fit.
</div>

<hr>

<p style = "text-align:center">
That's all.  Thanks for visiting.  I hope this was useful and/or fun.
<br><br>

By Shmoot
</p>

<p style = "font-size:small;text-align:center">
Possibly necessary fine print: I and this project have no affiliation with Spacechem, POV-Ray, or anyone who made those.  Also I probably should have considered earlier that there might already be something called PovChem that generates POV-Ray scenes of slightly less fake molecular models because <a target = "_blank" href = "http://www.chemicalgraphics.com/PovChem/">of course there is</a>.  There's no affiliation with that or its creator either.
</p>
</body>
</html>